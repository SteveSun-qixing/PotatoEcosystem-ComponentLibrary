# 薯片组件库 - 开发规范

**版本**: 1.1.0  
**更新时间**: 2026-02-01  
**技术栈**: Vue 3 + TypeScript

---

## 概述

本文档定义了薯片组件库的开发规范，是所有开发人员必须遵守的编码标准和最佳实践。

### 技术选型

薯片组件库使用 **Vue 3 + TypeScript** 作为实现框架：
- Vue 3.4+ (Composition API)
- TypeScript 5.0+
- 无样式组件（Unstyled Components）

> 详细的 Vue 3 开发规范请参考 [Vue 3 开发规范](其他开发规范.md)

### 强制性要求

本文档中的所有规范都是**强制性**的，不遵循规范的代码将无法通过Code Review，无法合并到主分支。

### 重要说明

**组件库不包含具体的基础卡片组件**（如 MarkdownCard、VideoCard 等）。根据薯片生态的架构设计，基础卡片组件应该在各自的插件中实现。组件库只提供：
- 通用 UI 组件（Button、Input、Modal 等）
- 布局组件（Grid、Flex、Layout 等）
- 表单组件（Form、FormItem 等）
- 卡片辅助组件（CardWrapper、CardLoading 等）

---

## 1. 通用开发规范

### 1.1 必须遵循的生态规范

所有开发必须首先遵循薯片生态的通用规范：

1. **[开发规范总则](../生态共用/08-开发规范总则.md)** - 生态级别的强制规范
2. **[前端接口标准](../生态共用/05-前端接口标准.md)** - 前端组件的标准接口
3. **[多语言系统规范](../生态共用/11-多语言系统规范.md)** - 多语言实现规范

### 1.2 核心原则

1. **中心路由架构**：所有与基础层和后端的通信必须通过微内核路由
2. **功能与样式分离**：组件代码中不包含任何样式代码
3. **零硬编码**：不硬编码文本、颜色、尺寸等
4. **多语言支持**：所有文本使用系统词汇编码
5. **主题系统**：暴露清晰的样式接口点
6. **基础层集成**：通过内核调用基础层功能

---

## 2. 功能与样式分离规范 ⭐

### 2.1 强制要求

**组件代码中不允许包含任何样式代码**。这是组件库的核心设计原则。

### 2.2 允许的内容

**✅ 允许**：
- 功能逻辑代码
- 事件处理代码
- 状态管理代码
- 数据处理代码
- 布局结构定义（DOM结构）
- CSS类名（作为样式接口点）

**❌ 禁止**：
- 任何颜色值
- 任何字体大小、字重
- 任何间距值（padding、margin）
- 任何边框样式
- 任何阴影效果
- 任何背景样式
- 内联style属性（除非动态计算的布局值）

### 2.3 示例

```vue
<!-- ❌ 错误：包含样式代码 -->
<template>
  <button 
    :style="{
      backgroundColor: '#1890ff',
      color: '#ffffff',
      padding: '8px 16px',
      borderRadius: '4px',
      fontSize: '14px'
    }"
    @click="onClick"
  >
    <slot />
  </button>
</template>

<!-- ❌ 禁止硬编码颜色、间距、圆角、字体大小 -->
```

```vue
<!-- ✅ 正确：只包含功能逻辑和样式接口点 -->
<script setup lang="ts">
interface ButtonProps {
  type?: 'default' | 'primary' | 'dashed' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
}

const props = withDefaults(defineProps<ButtonProps>(), {
  type: 'default',
  size: 'medium',
  disabled: false,
  loading: false
});

const emit = defineEmits<{
  click: [event: MouseEvent];
}>();

// 功能逻辑
const handleClick = (e: MouseEvent) => {
  if (props.disabled || props.loading) {
    e.preventDefault();
    return;
  }
  emit('click', e);
};
</script>

<template>
  <!-- 样式接口点：CSS类名 -->
  <button
    :class="[
      'chips-button',
      `chips-button--${type}`,
      `chips-button--${size}`,
      { 'chips-button--disabled': disabled || loading },
      { 'chips-button--loading': loading }
    ]"
    :disabled="disabled || loading"
    @click="handleClick"
  >
    <span v-if="loading" class="chips-button__spinner" />
    <span class="chips-button__content">
      <slot />
    </span>
  </button>
</template>

<!-- ❌ 不包含 <style> 标签 -->
```

### 2.4 动态计算的布局值

**唯一允许的内联style场景**：动态计算的布局值

```typescript
// ✅ 允许：动态计算的布局位置
function Dropdown({ visible, triggerElement }) {
  // 计算下拉菜单位置
  const position = useMemo(() => {
    if (!triggerElement) return {};
    const rect = triggerElement.getBoundingClientRect();
    return {
      top: rect.bottom + 4,   // ✅ 允许：动态计算的位置
      left: rect.left
    };
  }, [triggerElement]);
  
  return (
    <div 
      className="chips-dropdown"     // 样式由主题包提供
      style={position}                // ✅ 允许：动态计算的位置
    >
      {/* 内容 */}
    </div>
  );
}
```

---

## 3. 样式接口点规范

### 3.1 CSS类名命名规范

**格式**：`chips-[component]-[element]-[modifier]`

**规则**：
- 所有类名以`chips-`开头
- 组件名使用小写，多单词用连字符连接
- 元素名表示组件的子元素
- 修饰符表示变体、状态、尺寸

**示例**：
```typescript
// Button组件的类名
'chips-button'                    // 基础类
'chips-button-primary'            // 类型变体
'chips-button-lg'                 // 尺寸变体
'chips-button-disabled'           // 状态修饰符
'chips-button-loading'            // 状态修饰符
'chips-button-icon'               // 元素类
'chips-button-content'            // 元素类

// Modal组件的类名
'chips-modal'                     // 基础类
'chips-modal-mask'                // 遮罩元素
'chips-modal-wrap'                // 包装元素
'chips-modal-content'             // 内容元素
'chips-modal-header'              // 头部元素
'chips-modal-body'                // 主体元素
'chips-modal-footer'              // 底部元素
'chips-modal-close'               // 关闭按钮元素
```

### 3.2 类名组合

使用`classNames`工具函数组合类名：

```typescript
import classNames from 'classnames';

const className = classNames(
  'chips-button',                               // 基础类
  `chips-button-${type}`,                      // 动态类型
  `chips-button-${size}`,                      // 动态尺寸
  {
    'chips-button-disabled': disabled,         // 条件类
    'chips-button-loading': loading,           // 条件类
    'chips-button-block': block,               // 条件类
  },
  customClassName                               // 用户自定义类
);
```

### 3.3 样式接口点文档

每个组件必须在文档中列出所有样式接口点：

```markdown
### Button 样式接口点

| 类名 | 说明 | 使用场景 |
|-----|------|---------|
| `.chips-button` | 按钮基础样式 | 所有按钮 |
| `.chips-button-primary` | 主按钮样式 | type="primary" |
| `.chips-button-lg` | 大尺寸按钮 | size="large" |
| `.chips-button-disabled` | 禁用状态 | disabled=true |
| `.chips-button-loading` | 加载状态 | loading=true |
| `.chips-button-icon` | 图标元素 | 包含icon时 |
| `.chips-button-content` | 文本内容 | 所有按钮 |
```

---

## 4. 多语言规范 ⭐

### 4.1 强制要求

**代码中不允许包含任何硬编码的文本字符串**。所有文本必须通过多语言系统获取。

### 4.2 开发阶段

**使用人类可读的key**：

```typescript
import { t } from '@chips/i18n';

// ✅ 正确：使用key
function Button({ children }) {
  return (
    <button>
      {t('common.ok')}        // 开发时使用key
      {t('common.cancel')}
    </button>
  );
}

// ❌ 错误：硬编码文本
function Button({ children }) {
  return <button>确定</button>;  // ❌ 禁止硬编码
}
```

**词汇表定义**（`dev_i18n.yaml`）：

```yaml
common:
  ok: "确定"
  cancel: "取消"
  save: "保存"
  delete: "删除"

ui:
  loading: "加载中..."
  error: "发生错误"
  success: "操作成功"

button:
  submit: "提交"
  reset: "重置"
```

### 4.3 打包后

构建工具自动将key替换为系统词汇编码：

```typescript
// 打包前
t('common.ok')

// 打包后（自动替换）
t('i18n.core.000001')
```

### 4.4 变量插值

```typescript
// 支持变量
t('ui.file_count', { count: 10 })  // "共 10 个文件"
t('ui.delete_confirm', { name: '文件.txt' })  // "确定要删除 文件.txt 吗？"
```

### 4.5 完整规范

详见 [多语言系统规范](../生态共用/11-多语言系统规范.md)

---

## 5. 与基础层集成规范 ⭐

### 5.1 调用方式

**所有对基础层的调用必须通过微内核路由**：

```typescript
// ✅ 正确：通过Core.request调用
const response = await Core.request({
  target: 'VideoPlayer',
  action: 'render',
  params: { container, src }
});

// ❌ 错误：直接导入基础层模块
import { VideoPlayer } from '@chips/foundation';  // ❌ 禁止
VideoPlayer.render(container, src);               // ❌ 禁止
```

### 5.2 封装调用

**不要在组件中直接调用Core.request**，应封装为服务或Hook：

```typescript
// ✅ 推荐：封装为服务
class VideoPlayerService {
  static async render(container, options) {
    const response = await Core.request({
      target: 'VideoPlayer',
      action: 'render',
      params: { container, ...options }
    });
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data;
  }
}

// 在组件中使用
async function renderVideo() {
  await VideoPlayerService.render(this.containerRef.current, {
    src: this.props.src
  });
}

// ✅ 或封装为Hook
function useVideoPlayer(containerRef, src) {
  // ...
}
```

### 5.3 错误处理

```typescript
try {
  const response = await Core.request({ /* ... */ });
  
  if (!response.success) {
    // 处理业务错误
    console.error(response.error);
    this.showError(response.error.message);
  }
} catch (error) {
  // 处理系统错误
  console.error('系统错误:', error);
  this.showSystemError();
}
```

### 5.4 资源清理

```vue
<script setup lang="ts">
import { onUnmounted, ref } from 'vue';

const playerId = ref<string | null>(null);

// 清理基础层资源
onUnmounted(async () => {
  if (playerId.value) {
    await Core.request({
      target: 'VideoPlayer',
      action: 'destroy',
      params: { playerId: playerId.value }
    });
  }
});
</script>
```

### 5.5 完整规范

详见 [与基础层集成](技术文档/08-与基础层集成.md)

---

## 6. 代码风格规范

### 6.1 命名约定

**变量和函数**：camelCase
```typescript
const userName = 'John';
function getUserData() {}
```

**类和接口**：PascalCase
```typescript
class Button {}
interface ButtonProps {}
```

**常量**：UPPER_SNAKE_CASE
```typescript
const MAX_SIZE = 1000;
const DEFAULT_THEME = 'default';
```

**文件名**：kebab-case
```
button.tsx
date-picker.tsx
video-card.tsx
```

### 6.2 TypeScript类型

**所有Props必须有完整的TypeScript类型定义**：

```typescript
/**
 * 按钮组件 Props
 */
interface ButtonProps {
  /**
   * 按钮类型
   * @default 'default'
   */
  type?: 'default' | 'primary' | 'dashed' | 'link' | 'text';
  
  /**
   * 按钮尺寸
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';
  
  /**
   * 是否禁用
   * @default false
   */
  disabled?: boolean;
  
  /**
   * 是否加载中
   * @default false
   */
  loading?: boolean;
}

/**
 * 按钮组件 Emits
 */
interface ButtonEmits {
  click: [event: MouseEvent];
}
```

```vue
<script setup lang="ts">
const props = withDefaults(defineProps<ButtonProps>(), {
  type: 'default',
  size: 'medium',
  disabled: false,
  loading: false
});

const emit = defineEmits<ButtonEmits>();
</script>
```

### 6.3 导入顺序

```typescript
// 1. React相关
import React, { useState, useEffect } from 'react';

// 2. 第三方库
import classNames from 'classnames';
import { debounce } from 'lodash';

// 3. 内部模块
import { Core } from '@chips/core';
import { t } from '@chips/i18n';

// 4. 相对导入
import { Button } from '../Button';
import { Icon } from '../Icon';

// 5. 类型导入
import type { ButtonProps } from './types';

// 6. 样式导入（如果有）
import './index.css';
```

### 6.4 组件结构

```vue
<!--
  Button组件
  
  @example
  <Button type="primary" @click="handleClick">
    点击我
  </Button>
-->
<script setup lang="ts">
import { computed } from 'vue';

// 1. Props 和 Emits 定义
interface ButtonProps {
  type?: 'default' | 'primary' | 'dashed' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
}

const props = withDefaults(defineProps<ButtonProps>(), {
  type: 'default',
  size: 'medium',
  disabled: false,
  loading: false
});

const emit = defineEmits<{
  click: [event: MouseEvent];
}>();

// 2. 计算值
const buttonClass = computed(() => [
  'chips-button',
  `chips-button--${props.type}`,
  `chips-button--${props.size}`,
  { 'chips-button--disabled': props.disabled || props.loading },
  { 'chips-button--loading': props.loading }
]);

// 3. 事件处理
const handleClick = (e: MouseEvent) => {
  if (props.disabled || props.loading) {
    e.preventDefault();
    return;
  }
  emit('click', e);
};

// 4. 组合式函数（如有需要）
// const { theme } = useTheme();
</script>

<template>
  <!-- 5. 模板 -->
  <button
    :class="buttonClass"
    :disabled="disabled || loading"
    @click="handleClick"
  >
    <span v-if="loading" class="chips-button__spinner" />
    <span class="chips-button__icon">
      <slot name="icon" />
    </span>
    <span class="chips-button__content">
      <slot />
    </span>
  </button>
</template>

<!-- ❌ 不包含 <style> 标签 -->
```

---

## 7. 测试规范

### 7.1 测试覆盖率

**核心组件的测试覆盖率必须达到80%以上**。

### 7.2 测试类型

1. **单元测试**：测试组件的功能逻辑
2. **快照测试**：测试组件的渲染输出
3. **集成测试**：测试组件与基础层的集成
4. **无障碍测试**：测试可访问性

### 7.3 测试示例

```typescript
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from './Button.vue';

describe('Button', () => {
  // 单元测试
  it('应该渲染正确的类名', () => {
    const wrapper = mount(Button, {
      props: {
        type: 'primary',
        size: 'large'
      }
    });
    
    expect(wrapper.classes()).toContain('chips-button');
    expect(wrapper.classes()).toContain('chips-button--primary');
    expect(wrapper.classes()).toContain('chips-button--large');
  });
  
  it('应该处理点击事件', async () => {
    const wrapper = mount(Button, {
      slots: {
        default: '点击'
      }
    });
    
    await wrapper.trigger('click');
    expect(wrapper.emitted()).toHaveProperty('click');
    expect(wrapper.emitted('click')).toHaveLength(1);
  });
  
  it('禁用状态下不应触发点击', async () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      }
    });
    
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeUndefined();
  });
  
  // 加载状态测试
  it('加载中时应显示 spinner', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    });
    
    expect(wrapper.find('.chips-button__spinner').exists()).toBe(true);
  });
});
```

---

## 8. 文档规范

### 8.1 组件文档

每个组件必须有完整的文档，包括：

1. **组件说明**：组件的用途和功能
2. **何时使用**：使用场景
3. **代码示例**：基础用法和高级用法
4. **API文档**：Props、事件、方法
5. **样式接口点**：CSS类名列表

### 8.2 代码注释

```typescript
/**
 * Button组件
 * 
 * 用于触发操作的按钮组件
 * 
 * @example
 * ```tsx
 * // 基础用法
 * <Button onClick={handleClick}>点击我</Button>
 * 
 * // 主按钮
 * <Button type="primary">主要操作</Button>
 * 
 * // 带图标
 * <Button icon={<SearchIcon />}>搜索</Button>
 * ```
 */
export function Button(props: ButtonProps) {
  // 实现
}
```

---

## 9. 性能规范

### 9.1 避免不必要的渲染

```vue
<script setup lang="ts">
import { computed, shallowRef } from 'vue';

// 使用 computed 缓存计算结果
const buttonClass = computed(() => [
  'chips-button',
  `chips-button--${props.type}`
]);

// 使用 shallowRef 优化大型对象
const largeData = shallowRef<LargeData>({});

// 避免在模板中进行复杂计算
const formattedDate = computed(() => {
  return formatDate(props.date);
});
</script>

<template>
  <!-- ✅ 使用 computed 结果 -->
  <button :class="buttonClass">
    {{ formattedDate }}
  </button>
  
  <!-- ❌ 避免在模板中直接调用函数 -->
  <!-- <button :class="getButtonClass()">{{ formatDate(date) }}</button> -->
</template>
```

### 9.2 虚拟滚动

大列表组件必须支持虚拟滚动：

```typescript
function List({ items }) {
  const visibleRange = useVirtualScroll(items.length);
  const visibleItems = items.slice(visibleRange.start, visibleRange.end);
  
  return (
    <div>
      {visibleItems.map(item => <ListItem key={item.id} data={item} />)}
    </div>
  );
}
```

### 9.3 懒加载

```typescript
// 组件懒加载
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

// 使用
<Suspense fallback={<Loading />}>
  <HeavyComponent />
</Suspense>
```

---

## 10. 安全规范

### 10.1 XSS防护

```typescript
// ❌ 危险
element.innerHTML = userInput;

// ✅ 安全
element.textContent = userInput;

// 或使用DOMPurify
import DOMPurify from 'dompurify';
element.innerHTML = DOMPurify.sanitize(userInput);
```

### 10.2 输入验证

```typescript
// 验证Props
function Image({ src }: ImageProps) {
  if (!isValidUrl(src)) {
    throw new Error('Invalid image URL');
  }
  // 继续处理
}
```

---

## 11. Git规范

### 11.1 分支命名

- `feature/组件名` - 新功能
- `fix/问题描述` - Bug修复
- `refactor/模块名` - 重构
- `docs/文档名` - 文档更新

### 11.2 提交信息

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type**：
- `feat`: 新功能
- `fix`: Bug修复
- `docs`: 文档
- `style`: 格式
- `refactor`: 重构
- `test`: 测试
- `chore`: 构建/工具

**示例**：
```
feat(Button): 添加loading状态支持

添加loading prop和loading状态的视觉反馈

Closes #123
```

---

## 12. Code Review清单

提交PR前，确保通过以下检查：

- [ ] 代码不包含任何样式代码（颜色、字体、间距等）
- [ ] 代码不包含硬编码文本，使用多语言key
- [ ] 所有基础层调用通过Core.request
- [ ] 提供完整的TypeScript类型定义
- [ ] 暴露清晰的样式接口点（CSS类名）
- [ ] 测试覆盖率≥80%
- [ ] 通过所有测试
- [ ] 通过无障碍测试
- [ ] 提供完整的组件文档
- [ ] 提供代码示例
- [ ] 遵循命名约定
- [ ] 遵循代码结构规范
- [ ] 清理console.log和调试代码
- [ ] 提交信息符合规范

---

## 总结

薯片组件库的开发必须严格遵守以下核心原则：

1. **功能与样式完全分离**：不包含任何样式代码
2. **多语言支持**：不硬编码文本
3. **基础层集成**：通过内核调用基础层
4. **样式接口点**：暴露清晰的CSS类名
5. **类型安全**：完整的TypeScript类型
6. **测试完善**：覆盖率≥80%
7. **文档完整**：API文档和示例

遵循这些规范，确保组件库的代码质量、可维护性和可扩展性。

---

**维护团队**: 薯片生态核心团队  
**最后更新**: 2026-01-31
