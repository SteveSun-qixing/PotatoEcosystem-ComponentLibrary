# 薯片组件库 - 组件分类需求

**版本**: 1.0.0  
**更新时间**: 2026-01-31

---

## 概述

本文档定义了薯片组件库的组件分类体系、组件间关系和组合规则。所有组件都遵循**功能与样式分离**的原则，通过清晰的分类组织，实现高内聚低耦合的组件架构。

---

## 1. 组件分类体系

### 1.1 分类原则

1. **按功能职责分类**：根据组件的核心功能划分类别
2. **单一职责**：每个组件只负责一个明确的功能
3. **可组合性**：组件之间可以灵活组合
4. **层次清晰**：从原子组件到复合组件的清晰层次

### 1.2 分类结构

```
薯片组件库
├── 基础组件（Basic Components）
│   ├── 输入类组件
│   ├── 展示类组件
│   ├── 反馈类组件
│   └── 导航类组件
├── 布局组件（Layout Components）
├── 表单组件（Form Components）
├── 卡片辅助组件（Card Helper Components）
├── 数据组件（Data Components）
└── 特殊组件（Special Components）
```

> **重要说明**：具体的基础卡片组件（如 MarkdownCard、VideoCard、ImageCard 等）**不属于组件库**，它们应该在各自的**基础卡片插件**中实现。组件库只提供卡片辅助组件供插件开发时使用。

---

## 2. 基础组件（Basic Components）

### 2.1 定位

基础组件是最小的功能单元，提供单一明确的交互功能。这些组件不依赖其他业务组件，可以独立使用，也可以作为复合组件的构建基础。

### 2.2 分类

#### 输入类组件

**职责**：接收用户输入，提供交互控制

**包含组件**：
- Button（按钮）
- Input（输入框）
- Textarea（多行文本框）
- Select（选择器）
- Checkbox（复选框）
- Radio（单选框）
- Switch（开关）
- Slider（滑块）
- DatePicker（日期选择器）
- Upload（上传）

**共同特征**：
- 管理内部状态（受控/非受控）
- 触发值变化事件
- 支持禁用状态
- 支持验证状态

#### 展示类组件

**职责**：展示内容，不涉及输入

**包含组件**：
- Text（文本）
- Image（图片）
- Icon（图标）
- Tag（标签）
- Badge（徽标）
- Avatar（头像）
- Divider（分割线）

**共同特征**：
- 只读展示
- 不管理复杂状态
- 主要通过Props接收数据

#### 反馈类组件

**职责**：向用户反馈操作结果或状态

**包含组件**：
- Modal（对话框）
- Drawer（抽屉）
- Message（消息提示）
- Notification（通知）
- Tooltip（文字提示）
- Popover（气泡卡片）
- Loading（加载中）
- Progress（进度条）

**共同特征**：
- 临时出现的UI
- 通常有出现/消失动画
- 可以全局调用

#### 导航类组件

**职责**：提供页面或内容导航

**包含组件**：
- Menu（菜单）
- Tabs（标签页）
- Breadcrumb（面包屑）
- Pagination（分页）
- Dropdown（下拉菜单）

**共同特征**：
- 管理当前激活项
- 触发导航事件
- 支持层级结构

---

## 3. 布局组件（Layout Components）

### 3.1 定位

布局组件提供页面的整体结构和空间组织，负责子元素的排列和定位，但不直接实现业务功能。

### 3.2 包含组件

- Grid（栅格布局）
- Flex（弹性布局）
- Container（容器）
- Layout（整体布局框架）
- Space（间距控制）
- Card（卡片容器）
- Collapse（折叠面板）

### 3.3 特征

- **只负责布局**：不包含具体业务逻辑
- **接收任意子元素**：通过children prop接收内容
- **响应式**：支持不同屏幕尺寸的布局调整
- **可嵌套**：布局组件可以相互嵌套使用

### 3.4 使用场景

```tsx
// 页面整体布局
<Layout>
  <Layout.Header>
    <Menu />
  </Layout.Header>
  <Layout>
    <Layout.Sider>
      <Menu />
    </Layout.Sider>
    <Layout.Content>
      <Grid>
        <Grid.Row>
          <Grid.Col span={12}>
            <Card>内容1</Card>
          </Grid.Col>
          <Grid.Col span={12}>
            <Card>内容2</Card>
          </Grid.Col>
        </Grid.Row>
      </Grid>
    </Layout.Content>
  </Layout>
  <Layout.Footer>
    页脚
  </Layout.Footer>
</Layout>
```

---

## 4. 表单组件（Form Components）

### 4.1 定位

表单组件专门用于构建和管理表单，提供数据收集、验证、提交等功能。

### 4.2 包含组件

- Form（表单容器）
- FormItem（表单项）
- FormList（动态表单项列表）

### 4.3 特征

- **统一数据管理**：集中管理表单数据
- **验证机制**：提供表单验证功能
- **错误提示**：显示验证错误信息
- **布局支持**：支持多种表单布局

### 4.4 与基础组件的关系

表单组件包装基础输入组件，添加验证、标签、错误提示等功能：

```tsx
<Form>
  <FormItem label="用户名" name="username" rules={[{ required: true }]}>
    <Input />
  </FormItem>
  <FormItem label="密码" name="password" rules={[{ required: true }]}>
    <Input type="password" />
  </FormItem>
  <FormItem>
    <Button type="primary" htmlType="submit">提交</Button>
  </FormItem>
</Form>
```

---

## 5. 卡片辅助组件（Card Helper Components）

### 5.1 定位

卡片辅助组件为基础卡片插件开发提供通用的 UI 辅助功能，包括卡片包装器、加载状态、错误状态等。

> **重要说明**：具体的基础卡片组件（如 MarkdownCard、VideoCard、ImageCard 等）**不属于组件库**。根据薯片生态的架构设计，每种基础卡片都是一个独立的插件包，包含自己的渲染组件和编辑组件。详见 [插件开发规范](../../生态共用/07-插件开发规范.md) 和 [基础卡片插件的结构](../../生态设计原稿（一切标准）/03-基础卡片插件的结构.md)。

### 5.2 包含组件

- CardWrapper（卡片包装器）
- CardHeader（卡片头部）
- CardLoading（卡片加载状态）
- CardError（卡片错误状态）
- CardPlaceholder（卡片占位符）

### 5.3 特征

- **辅助性质**：为插件开发提供通用 UI 组件
- **可选使用**：插件可以选择是否使用这些辅助组件
- **主题支持**：支持主题系统
- **解耦设计**：与具体卡片类型无关

### 5.4 使用场景

基础卡片插件开发时，可以使用这些辅助组件：

```typescript
// 在视频卡片插件中使用卡片辅助组件
import { CardWrapper, CardLoading, CardError } from '@chips/components';

class VideoCardRenderer {
  render(config, container) {
    // 使用 CardWrapper 包装卡片内容
    const wrapper = new CardWrapper({
      cardId: config.id,
      cardType: 'video',
      theme: config.theme
    });
    
    // 显示加载状态
    wrapper.setContent(new CardLoading({ tip: 'loading.video' }));
    
    // 加载完成后替换为实际内容
    this.loadVideo().then(player => {
      wrapper.setContent(player.element);
    }).catch(error => {
      wrapper.setContent(new CardError({ error, retryable: true }));
    });
  }
}
```

### 5.5 基础卡片插件的正确位置

基础卡片的渲染组件和编辑组件应该在各自的插件中实现：

| 基础卡片类型 | 所属插件 | 调用的基础层模块 |
|-------------|---------|----------------|
| Markdown卡片 | chips-plugin-markdown | MarkdownParser、CodeHighlighter |
| 富文本卡片 | chips-plugin-richtext | RichTextRenderer |
| 图片卡片 | chips-plugin-image | ImageViewer |
| 视频卡片 | chips-plugin-video | VideoPlayer |
| 音乐卡片 | chips-plugin-audio | AudioPlayer |
| 代码块卡片 | chips-plugin-codeblock | CodeHighlighter |
| 网页卡片 | chips-plugin-webpage | IFrameWrapper |

---

## 6. 数据组件（Data Components）

### 6.1 定位

数据组件用于展示和操作大量结构化数据，提供排序、筛选、分页等功能。

### 6.2 包含组件

- Table（表格）
- List（列表）
- Tree（树形控件）

### 6.3 特征

- **大数据量优化**：支持虚拟滚动
- **数据操作**：支持排序、筛选、搜索
- **状态管理**：管理展开/折叠、选中等状态
- **自定义渲染**：支持自定义单元格/列表项渲染

### 6.4 性能要求

- 支持虚拟滚动，渲染万条数据不卡顿
- 大量数据操作响应时间 < 100ms
- 支持按需加载数据

---

## 7. 特殊组件（Special Components）

### 7.1 定位

特殊组件提供全局功能或上下文管理，不直接展示UI，而是为其他组件提供服务。

### 7.2 包含组件

- ThemeProvider（主题提供者）
- ChipsProvider（生态提供者）
- ErrorBoundary（错误边界）

### 7.3 特征

- **Context提供者**：为子组件提供上下文
- **全局功能**：提供全局配置和服务
- **无UI**：不直接渲染可见UI

### 7.4 使用方式

```tsx
// 应用根组件
<ChipsProvider kernelConnection={connection} config={config}>
  <ThemeProvider theme="default">
    <ErrorBoundary fallback={<ErrorPage />}>
      <App />
    </ErrorBoundary>
  </ThemeProvider>
</ChipsProvider>
```

---

## 8. 组件间关系

### 8.1 依赖关系

```
特殊组件（Context提供者）
    ↓ 提供上下文
布局组件、表单组件
    ↓ 组合使用
基础组件
    ↓ 组合使用
复合组件、卡片组件、数据组件
```

### 8.2 组合规则

#### 规则1：基础组件独立

基础组件不依赖其他业务组件，可以独立使用：

```tsx
// ✅ 正确：独立使用基础组件
<Button onClick={handleClick}>点击</Button>
```

#### 规则2：布局组件接收任意子元素

布局组件通过children接收内容，不限制子元素类型：

```tsx
// ✅ 正确：布局组件包装任意内容
<Card>
  <Text>任意内容</Text>
  <Button>操作按钮</Button>
</Card>
```

#### 规则3：表单组件包装输入组件

FormItem包装输入类基础组件，添加标签和验证：

```tsx
// ✅ 正确：FormItem包装输入组件
<FormItem label="用户名" name="username">
  <Input />
</FormItem>
```

#### 规则4：卡片组件调用基础层

卡片组件不直接操作DOM，通过基础层模块实现功能：

```tsx
// ✅ 正确：通过基础层渲染视频
async renderVideo() {
  await Core.request({
    target: 'VideoPlayer',
    action: 'render',
    params: { container: this.container, src: this.props.src }
  });
}
```

#### 规则5：数据组件可嵌套基础组件

数据组件通过render props或slot自定义渲染内容：

```tsx
// ✅ 正确：Table自定义单元格渲染
<Table
  columns={[
    {
      title: '操作',
      render: (record) => (
        <Space>
          <Button size="small">编辑</Button>
          <Button size="small">删除</Button>
        </Space>
      )
    }
  ]}
/>
```

---

## 9. 样式接口点规范

### 9.1 命名规范

所有组件必须遵循统一的CSS类名命名规范：

**格式**：`chips-[component]-[element]-[modifier]`

**示例**：
- `.chips-button`：按钮基础类
- `.chips-button-primary`：主按钮变体
- `.chips-button-icon`：按钮图标元素
- `.chips-button-disabled`：禁用状态
- `.chips-button-loading`：加载状态

### 9.2 层级规范

每个组件必须有清晰的样式接口点层级：

```html
<!-- Button组件的样式接口点 -->
<button class="chips-button chips-button-primary chips-button-lg">
  <span class="chips-button-icon">图标</span>
  <span class="chips-button-content">文本</span>
</button>
```

### 9.3 状态类

状态类通过modifier类名表示：

- `.chips-[component]-disabled`：禁用状态
- `.chips-[component]-loading`：加载状态
- `.chips-[component]-active`：激活状态
- `.chips-[component]-selected`：选中状态
- `.chips-[component]-error`：错误状态

---

## 10. 与公共基础层的集成

### 10.1 集成原则

1. **不重复造轮子**：基础层已有的功能直接调用，不重复实现
2. **通过内核路由**：所有调用通过微内核路由，不直接依赖
3. **职责清晰**：组件库专注业务级UI，基础功能由基础层提供
4. **完全解耦**：组件库和基础层通过内核完全解耦

### 10.2 主要集成模块

| 基础层模块 | 组件库使用场景 |
|-----------|---------------|
| UIControls | 创建基础控件元素 |
| DragDropSystem | 实现拖拽功能（Tree、Table等） |
| WindowManager | 创建模态窗口（Modal） |
| ImageViewer | 图片预览和显示 |
| VideoPlayer | 视频播放 |
| AudioPlayer | 音频播放 |
| MarkdownParser | Markdown解析 |
| CodeHighlighter | 代码高亮 |
| RichTextRenderer | 富文本渲染 |
| IFrameWrapper | 网页嵌入 |
| I18nSystem | 多语言支持 |

### 10.3 调用示例

```typescript
// 1. 调用UIControls创建基础按钮
async function createButton() {
  const response = await Core.request({
    target: 'UIControls',
    action: 'createButton',
    params: { text: '点击我' }
  });
  return response.data.element;
}

// 2. 调用DragDropSystem实现拖拽
async function enableDrag(element: HTMLElement) {
  await Core.request({
    target: 'DragDropSystem',
    action: 'enableDrag',
    params: {
      element,
      options: {
        onDragStart: () => {},
        onDragEnd: () => {}
      }
    }
  });
}

// 3. 调用VideoPlayer播放视频
async function playVideo(container: HTMLElement, src: string) {
  await Core.request({
    target: 'VideoPlayer',
    action: 'render',
    params: { container, src }
  });
}
```

---

## 11. 总结

薯片组件库采用清晰的分类体系，提供通用UI组件，形成完整的组件生态。所有组件遵循：

1. **功能与样式分离**：组件只实现功能，样式由主题包提供
2. **单一职责**：每个组件职责明确
3. **可组合**：组件之间可以灵活组合
4. **基础层集成**：调用公共基础层的通用功能
5. **标准接口**：通过内核路由通信

**重要说明**：

- 组件库**不包含具体的基础卡片组件**（如 MarkdownCard、VideoCard 等）
- 基础卡片组件应该在各自的**插件**中实现
- 组件库只提供**卡片辅助组件**供插件开发时使用

通过合理的分类和清晰的职责划分，确保组件库易于理解、易于维护、易于扩展。

---

**维护团队**: 薯片生态核心团队  
**最后更新**: 2026-01-31
