# 基础组件库设计

## 概述

基础组件是构建界面的最小功能单元，提供单一明确的功能。本文档详细说明核心基础组件的设计实现。

## Button 按钮

### 组件设计

```typescript
interface ButtonProps {
  type?: 'default' | 'primary' | 'dashed' | 'link' | 'text';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  danger?: boolean;
  icon?: ReactNode;
  htmlType?: 'button' | 'submit' | 'reset';
  children?: ReactNode;
  onClick?: (event: MouseEvent<HTMLButtonElement>) => void;
  className?: string;
}

export function Button({
  type = 'default',
  size = 'medium',
  disabled = false,
  loading = false,
  danger = false,
  icon,
  htmlType = 'button',
  children,
  onClick,
  className,
  ...rest
}: ButtonProps) {
  const buttonClassName = classNames(
    'chips-button',
    `chips-button-${type}`,
    `chips-button-${size}`,
    {
      'chips-button-disabled': disabled || loading,
      'chips-button-loading': loading,
      'chips-button-danger': danger,
      'chips-button-icon-only': icon && !children,
    },
    className
  );
  
  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    if (disabled || loading) {
      event.preventDefault();
      return;
    }
    onClick?.(event);
  };
  
  return (
    <button
      type={htmlType}
      className={buttonClassName}
      onClick={handleClick}
      disabled={disabled || loading}
      {...rest}
    >
      {loading && <LoadingIcon className="chips-button-loading-icon" />}
      {icon && !loading && <span className="chips-button-icon">{icon}</span>}
      {children && <span className="chips-button-content">{children}</span>}
    </button>
  );
}
```

### 样式接口点

```css
.chips-button {
  /* 容器样式接口点 */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: var(--chips-button-height-base);
  padding: 0 var(--chips-button-padding-horizontal);
  font-size: var(--chips-font-size-base);
  font-weight: var(--chips-font-weight-medium);
  line-height: var(--chips-line-height-base);
  border-radius: var(--chips-border-radius-base);
  border: 1px solid var(--chips-color-border);
  background-color: var(--chips-color-bg-base);
  color: var(--chips-color-text-primary);
  cursor: pointer;
  transition: all var(--chips-transition-fast);
  user-select: none;
}

.chips-button-primary {
  background-color: var(--chips-color-primary);
  border-color: var(--chips-color-primary);
  color: #ffffff;
}

.chips-button-disabled {
  cursor: not-allowed;
  opacity: 0.6;
}

.chips-button-loading-icon {
  margin-right: var(--chips-spacing-xs);
  animation: spin 1s linear infinite;
}

.chips-button-icon {
  margin-right: var(--chips-spacing-xs);
}

.chips-button-icon-only .chips-button-icon {
  margin-right: 0;
}
```

## Input 输入框

### 组件设计

```typescript
interface InputProps {
  value?: string;
  defaultValue?: string;
  type?: 'text' | 'password' | 'number' | 'email' | 'tel' | 'url';
  placeholder?: string;
  disabled?: boolean;
  readOnly?: boolean;
  maxLength?: number;
  prefix?: ReactNode;
  suffix?: ReactNode;
  clearable?: boolean;
  onChange?: (value: string, event: ChangeEvent<HTMLInputElement>) => void;
  onFocus?: (event: FocusEvent<HTMLInputElement>) => void;
  onBlur?: (event: FocusEvent<HTMLInputElement>) => void;
  onPressEnter?: (event: KeyboardEvent<HTMLInputElement>) => void;
  className?: string;
}

export function Input({
  value: controlledValue,
  defaultValue,
  type = 'text',
  placeholder,
  disabled = false,
  readOnly = false,
  maxLength,
  prefix,
  suffix,
  clearable = false,
  onChange,
  onFocus,
  onBlur,
  onPressEnter,
  className,
  ...rest
}: InputProps) {
  const isControlled = controlledValue !== undefined;
  const [internalValue, setInternalValue] = useState(defaultValue || '');
  const [focused, setFocused] = useState(false);
  
  const value = isControlled ? controlledValue : internalValue;
  const showClear = clearable && value && !disabled && !readOnly;
  
  const containerClassName = classNames(
    'chips-input-container',
    {
      'chips-input-focused': focused,
      'chips-input-disabled': disabled,
      'chips-input-has-prefix': prefix,
      'chips-input-has-suffix': suffix || showClear,
    },
    className
  );
  
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    const newValue = event.target.value;
    
    if (!isControlled) {
      setInternalValue(newValue);
    }
    
    onChange?.(newValue, event);
  };
  
  const handleClear = () => {
    const newValue = '';
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue, {} as any);
  };
  
  const handleKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {
    if (event.key === 'Enter') {
      onPressEnter?.(event);
    }
  };
  
  return (
    <div className={containerClassName}>
      {prefix && <span className="chips-input-prefix">{prefix}</span>}
      <input
        type={type}
        className="chips-input"
        value={value}
        placeholder={placeholder}
        disabled={disabled}
        readOnly={readOnly}
        maxLength={maxLength}
        onChange={handleChange}
        onFocus={(e) => { setFocused(true); onFocus?.(e); }}
        onBlur={(e) => { setFocused(false); onBlur?.(e); }}
        onKeyDown={handleKeyDown}
        {...rest}
      />
      {showClear && (
        <button
          type="button"
          className="chips-input-clear"
          onClick={handleClear}
        >
          <CloseIcon />
        </button>
      )}
      {suffix && !showClear && (
        <span className="chips-input-suffix">{suffix}</span>
      )}
    </div>
  );
}
```

### 样式接口点

```css
.chips-input-container {
  display: inline-flex;
  align-items: center;
  width: 100%;
  border: 1px solid var(--chips-color-border);
  border-radius: var(--chips-border-radius-base);
  background-color: var(--chips-color-bg-base);
  transition: all var(--chips-transition-fast);
}

.chips-input-focused {
  border-color: var(--chips-color-primary);
  box-shadow: 0 0 0 2px var(--chips-color-primary-light);
}

.chips-input {
  flex: 1;
  height: var(--chips-input-height-base);
  padding: 0 var(--chips-spacing-sm);
  font-size: var(--chips-font-size-base);
  line-height: var(--chips-line-height-base);
  color: var(--chips-color-text-primary);
  background: transparent;
  border: none;
  outline: none;
}

.chips-input-prefix,
.chips-input-suffix {
  padding: 0 var(--chips-spacing-sm);
  color: var(--chips-color-text-secondary);
}

.chips-input-clear {
  padding: 0 var(--chips-spacing-sm);
  color: var(--chips-color-text-secondary);
  background: transparent;
  border: none;
  cursor: pointer;
}
```

## Select 选择器

### 组件设计

```typescript
interface SelectOption {
  label: string;
  value: string | number;
  disabled?: boolean;
}

interface SelectProps {
  value?: string | number;
  defaultValue?: string | number;
  options: SelectOption[];
  placeholder?: string;
  disabled?: boolean;
  searchable?: boolean;
  clearable?: boolean;
  onChange?: (value: string | number, option: SelectOption) => void;
  className?: string;
}

export function Select({
  value: controlledValue,
  defaultValue,
  options,
  placeholder = '请选择',
  disabled = false,
  searchable = false,
  clearable = false,
  onChange,
  className,
}: SelectProps) {
  const isControlled = controlledValue !== undefined;
  const [internalValue, setInternalValue] = useState(defaultValue);
  const [open, setOpen] = useState(false);
  const [searchText, setSearchText] = useState('');
  
  const value = isControlled ? controlledValue : internalValue;
  
  const selectedOption = options.find(opt => opt.value === value);
  
  const filteredOptions = searchable
    ? options.filter(opt =>
        opt.label.toLowerCase().includes(searchText.toLowerCase())
      )
    : options;
  
  const handleSelect = (option: SelectOption) => {
    if (option.disabled) return;
    
    const newValue = option.value;
    
    if (!isControlled) {
      setInternalValue(newValue);
    }
    
    onChange?.(newValue, option);
    setOpen(false);
    setSearchText('');
  };
  
  const handleClear = (event: MouseEvent) => {
    event.stopPropagation();
    
    if (!isControlled) {
      setInternalValue(undefined);
    }
    
    onChange?.('' as any, {} as SelectOption);
  };
  
  return (
    <div className={classNames('chips-select', className)}>
      <div
        className={classNames('chips-select-selector', {
          'chips-select-open': open,
          'chips-select-disabled': disabled,
        })}
        onClick={() => !disabled && setOpen(!open)}
      >
        <span className="chips-select-selection-item">
          {selectedOption?.label || placeholder}
        </span>
        {clearable && value && (
          <button
            className="chips-select-clear"
            onClick={handleClear}
          >
            <CloseIcon />
          </button>
        )}
        <span className="chips-select-arrow">
          <DownIcon />
        </span>
      </div>
      
      {open && (
        <div className="chips-select-dropdown">
          {searchable && (
            <div className="chips-select-search">
              <input
                type="text"
                value={searchText}
                placeholder="搜索..."
                onChange={(e) => setSearchText(e.target.value)}
              />
            </div>
          )}
          <div className="chips-select-options">
            {filteredOptions.map(option => (
              <div
                key={option.value}
                className={classNames('chips-select-option', {
                  'chips-select-option-selected': option.value === value,
                  'chips-select-option-disabled': option.disabled,
                })}
                onClick={() => handleSelect(option)}
              >
                {option.label}
              </div>
            ))}
            {filteredOptions.length === 0 && (
              <div className="chips-select-empty">暂无数据</div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```

## Checkbox 复选框

### 组件设计

```typescript
interface CheckboxProps {
  checked?: boolean;
  defaultChecked?: boolean;
  disabled?: boolean;
  indeterminate?: boolean;
  children?: ReactNode;
  onChange?: (checked: boolean, event: ChangeEvent<HTMLInputElement>) => void;
  className?: string;
}

export function Checkbox({
  checked: controlledChecked,
  defaultChecked,
  disabled = false,
  indeterminate = false,
  children,
  onChange,
  className,
}: CheckboxProps) {
  const isControlled = controlledChecked !== undefined;
  const [internalChecked, setInternalChecked] = useState(defaultChecked || false);
  
  const checked = isControlled ? controlledChecked : internalChecked;
  
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    const newChecked = event.target.checked;
    
    if (!isControlled) {
      setInternalChecked(newChecked);
    }
    
    onChange?.(newChecked, event);
  };
  
  return (
    <label
      className={classNames(
        'chips-checkbox',
        {
          'chips-checkbox-checked': checked,
          'chips-checkbox-indeterminate': indeterminate,
          'chips-checkbox-disabled': disabled,
        },
        className
      )}
    >
      <input
        type="checkbox"
        className="chips-checkbox-input"
        checked={checked}
        disabled={disabled}
        onChange={handleChange}
      />
      <span className="chips-checkbox-box">
        {indeterminate ? (
          <MinusIcon className="chips-checkbox-icon" />
        ) : checked ? (
          <CheckIcon className="chips-checkbox-icon" />
        ) : null}
      </span>
      {children && (
        <span className="chips-checkbox-label">{children}</span>
      )}
    </label>
  );
}
```

## Modal 对话框

### 组件设计

```typescript
interface ModalProps {
  visible?: boolean;
  title?: ReactNode;
  width?: number | string;
  closable?: boolean;
  maskClosable?: boolean;
  footer?: ReactNode;
  onOk?: () => void | Promise<void>;
  onCancel?: () => void;
  children?: ReactNode;
  className?: string;
}

export function Modal({
  visible = false,
  title,
  width = 520,
  closable = true,
  maskClosable = true,
  footer,
  onOk,
  onCancel,
  children,
  className,
}: ModalProps) {
  const [confirmLoading, setConfirmLoading] = useState(false);
  
  // ESC键关闭
  useEffect(() => {
    if (!visible) return;
    
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && closable) {
        onCancel?.();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [visible, closable, onCancel]);
  
  // 阻止body滚动
  useEffect(() => {
    if (visible) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    
    return () => {
      document.body.style.overflow = '';
    };
  }, [visible]);
  
  const handleOk = async () => {
    if (confirmLoading) return;
    
    try {
      setConfirmLoading(true);
      await onOk?.();
    } finally {
      setConfirmLoading(false);
    }
  };
  
  const handleMaskClick = () => {
    if (maskClosable && !confirmLoading) {
      onCancel?.();
    }
  };
  
  if (!visible) return null;
  
  return createPortal(
    <div className="chips-modal-root">
      <div className="chips-modal-mask" onClick={handleMaskClick} />
      <div className="chips-modal-wrap">
        <div
          className={classNames('chips-modal', className)}
          style={{ width }}
        >
          <div className="chips-modal-content">
            {title && (
              <div className="chips-modal-header">
                <div className="chips-modal-title">{title}</div>
                {closable && (
                  <button
                    className="chips-modal-close"
                    onClick={onCancel}
                  >
                    <CloseIcon />
                  </button>
                )}
              </div>
            )}
            <div className="chips-modal-body">{children}</div>
            {footer !== null && (
              <div className="chips-modal-footer">
                {footer || (
                  <>
                    <Button onClick={onCancel}>取消</Button>
                    <Button
                      type="primary"
                      loading={confirmLoading}
                      onClick={handleOk}
                    >
                      确定
                    </Button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>,
    document.body
  );
}
```

## 其他基础组件

### Radio 单选框

类似Checkbox的实现模式，使用radio input类型。

### Switch 开关

类似Checkbox的实现，使用自定义的开关UI。

### Slider 滑块

使用range input实现，提供拖拽交互。

### DatePicker 日期选择器

集成第三方日期选择库（如date-fns），提供标准化接口。

### Upload 上传

处理文件选择、上传进度、预览等功能。

### Tooltip 文字提示

使用Popper.js实现定位，提供hover/click触发。

### Popover 气泡卡片

类似Tooltip，支持更丰富的内容。

### Loading 加载中

提供多种加载动画样式，支持全屏和局部加载。

### Progress 进度条

实现线形和环形进度条，支持百分比显示。

## 组件库导出

```typescript
// src/index.ts
export { Button } from './Button';
export { Input } from './Input';
export { Select } from './Select';
export { Checkbox } from './Checkbox';
export { Radio } from './Radio';
export { Switch } from './Switch';
export { Modal } from './Modal';
// ... 导出所有组件

export type { ButtonProps } from './Button';
export type { InputProps } from './Input';
// ... 导出所有类型
```

## 总结

基础组件库提供了构建界面的基础单元。每个组件都遵循功能与样式分离的原则，提供清晰的Props接口和样式接口点。组件支持受控和非受控模式，提供完整的TypeScript类型定义，确保了易用性和类型安全。
