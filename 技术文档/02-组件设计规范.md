# 组件设计规范

## 设计原则

### 单一职责

每个组件只负责一个明确的功能：

- **Button**：只负责按钮交互，不包含表单逻辑
- **Input**：只负责输入框，不包含验证逻辑（验证由FormItem处理）
- **Select**：只负责选择，不包含数据获取逻辑

组件应该小而专注，复杂功能通过组合多个组件实现。

### 功能与样式分离

组件代码中不包含任何视觉样式：

**✅ 正确做法**
```typescript
// 只定义结构和功能
<button 
  className="chips-button chips-button-primary"
  onClick={handleClick}
  disabled={disabled}
>
  {children}
</button>
```

**❌ 错误做法**
```typescript
// 不要在组件中硬编码样式
<button 
  style={{ 
    backgroundColor: '#1890ff',  // ❌ 不要硬编码样式
    padding: '8px 16px',         // ❌ 不要硬编码样式
    borderRadius: '4px'          // ❌ 不要硬编码样式
  }}
>
  {children}
</button>
```

### 可组合性

组件应该可以灵活组合：

```typescript
// Button可以包含Icon
<Button>
  <Icon name="search" />
  搜索
</Button>

// Input可以有前缀后缀
<Input 
  prefix={<Icon name="user" />}
  suffix={<Icon name="close" />}
/>

// Modal可以自定义内容和footer
<Modal
  title="确认删除"
  footer={<Button onClick={handleDelete}>删除</Button>}
>
  <Text>确定要删除这个卡片吗？</Text>
</Modal>
```

### 受控与非受控

组件同时支持受控和非受控两种模式：

**受控模式**：值由父组件控制
```typescript
<Input 
  value={inputValue} 
  onChange={(e) => setInputValue(e.target.value)} 
/>
```

**非受控模式**：组件自己管理状态
```typescript
<Input defaultValue="初始值" />
```

### 可访问性优先

组件设计考虑无障碍访问：

- 提供语义化的HTML标签
- 添加适当的ARIA属性
- 支持键盘导航
- 提供清晰的焦点指示
- 确保文本对比度

## Props设计规范

### 命名规范

**布尔类型Props**：使用 is/has/should/can 前缀
```typescript
interface ButtonProps {
  disabled?: boolean;        // 状态类直接用形容词
  loading?: boolean;         // 状态类直接用形容词
  isActive?: boolean;        // 使用is前缀
  hasIcon?: boolean;         // 使用has前缀
  shouldAutoFocus?: boolean; // 使用should前缀
  canSubmit?: boolean;       // 使用can前缀
}
```

**事件回调Props**：使用 on 前缀
```typescript
interface InputProps {
  onClick?: (event: MouseEvent) => void;
  onChange?: (value: string) => void;
  onFocus?: (event: FocusEvent) => void;
  onBlur?: (event: FocusEvent) => void;
  onPressEnter?: (event: KeyboardEvent) => void;
}
```

**渲染函数Props**：使用 render 前缀
```typescript
interface ListProps {
  renderItem?: (item: any, index: number) => ReactNode;
  renderEmpty?: () => ReactNode;
  renderLoading?: () => ReactNode;
}
```

**样式相关Props**：使用明确的名称
```typescript
interface ComponentProps {
  className?: string;        // 自定义类名
  style?: CSSProperties;     // 内联样式（尽量避免使用）
  size?: 'small' | 'medium' | 'large';  // 尺寸
  variant?: 'primary' | 'secondary';    // 变体
}
```

### Props类型定义

使用TypeScript严格定义Props类型：

```typescript
interface ButtonProps {
  // 基础属性
  type?: 'default' | 'primary' | 'dashed' | 'link' | 'text';
  size?: 'small' | 'medium' | 'large';
  
  // 状态属性
  disabled?: boolean;
  loading?: boolean;
  
  // 内容属性
  children?: ReactNode;
  icon?: ReactNode;
  
  // 事件回调
  onClick?: (event: MouseEvent<HTMLButtonElement>) => void;
  
  // 样式属性
  className?: string;
  
  // HTML原生属性
  htmlType?: 'button' | 'submit' | 'reset';
  
  // 其他
  autoFocus?: boolean;
  danger?: boolean;
}
```

### 必需与可选Props

明确区分必需和可选Props：

```typescript
interface ImageCardProps {
  // 必需Props
  src: string;              // 图片地址必需
  
  // 可选Props
  alt?: string;             // 替代文本可选
  width?: number;           // 宽度可选
  height?: number;          // 高度可选
  caption?: string;         // 说明可选
  lazy?: boolean;           // 懒加载可选，默认true
  preview?: boolean;        // 预览可选，默认true
}
```

### 默认值

为可选Props提供合理的默认值：

```typescript
function Button({
  type = 'default',
  size = 'medium',
  disabled = false,
  loading = false,
  htmlType = 'button',
  children,
  onClick,
  ...rest
}: ButtonProps) {
  // 组件实现
}
```

### Props文档注释

为每个Props添加详细的文档注释：

```typescript
interface ButtonProps {
  /**
   * 按钮类型
   * @default 'default'
   */
  type?: 'default' | 'primary' | 'dashed' | 'link' | 'text';
  
  /**
   * 按钮尺寸
   * @default 'medium'
   */
  size?: 'small' | 'medium' | 'large';
  
  /**
   * 是否禁用
   * @default false
   */
  disabled?: boolean;
  
  /**
   * 是否加载中
   * @default false
   */
  loading?: boolean;
  
  /**
   * 按钮图标
   */
  icon?: ReactNode;
  
  /**
   * 点击事件回调
   */
  onClick?: (event: MouseEvent<HTMLButtonElement>) => void;
}
```

## 事件处理规范

### 事件命名

事件回调使用 on 前缀：

```typescript
interface Props {
  onClick?: (event: MouseEvent) => void;
  onChange?: (value: string) => void;
  onSubmit?: (values: FormValues) => void;
  onSuccess?: (data: any) => void;
  onError?: (error: Error) => void;
}
```

### 事件参数

根据使用场景选择合适的事件参数：

**传递原生事件对象**：需要访问DOM或阻止默认行为
```typescript
onClick?: (event: MouseEvent<HTMLButtonElement>) => void;
```

**传递处理后的值**：简化使用，隐藏实现细节
```typescript
onChange?: (value: string) => void;
```

**传递多个参数**：需要提供额外信息
```typescript
onSelect?: (value: string, option: Option) => void;
```

**传递对象**：参数较多时
```typescript
onFinish?: (values: FormValues) => void;
```

### 事件合成

组件内部处理和外部回调都执行：

```typescript
function Input({ value, onChange, onPressEnter }: InputProps) {
  const handleKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {
    // 组件内部处理
    if (event.key === 'Enter') {
      onPressEnter?.(event);  // 调用外部回调
    }
  };
  
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    const newValue = event.target.value;
    // 组件内部状态更新
    setInternalValue(newValue);
    // 调用外部回调
    onChange?.(newValue);
  };
  
  return (
    <input 
      value={value}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
    />
  );
}
```

### 阻止事件冒泡

需要时阻止事件冒泡：

```typescript
const handleClick = (event: MouseEvent) => {
  if (disabled) {
    event.preventDefault();
    event.stopPropagation();
    return;
  }
  onClick?.(event);
};
```

## 状态管理规范

### 组件内部状态

使用useState管理组件内部状态：

```typescript
function Select({ value, defaultValue, onChange }: SelectProps) {
  // 是否受控
  const isControlled = value !== undefined;
  
  // 内部状态（非受控模式使用）
  const [internalValue, setInternalValue] = useState(defaultValue);
  
  // 实际使用的值
  const actualValue = isControlled ? value : internalValue;
  
  const handleChange = (newValue: string) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue);
  };
  
  return (
    // 使用actualValue
  );
}
```

### 状态更新

批量更新状态：

```typescript
// ❌ 避免多次更新
setOpen(true);
setLoading(false);
setData(newData);

// ✅ 使用对象批量更新
setState({
  open: true,
  loading: false,
  data: newData
});
```

### 派生状态

使用useMemo计算派生状态：

```typescript
function Table({ dataSource, filters }: TableProps) {
  // 派生状态：过滤后的数据
  const filteredData = useMemo(() => {
    return dataSource.filter(item => {
      return Object.entries(filters).every(([key, value]) => {
        return item[key] === value;
      });
    });
  }, [dataSource, filters]);
  
  return <>{/* 使用filteredData */}</>;
}
```

### 副作用

使用useEffect处理副作用：

```typescript
function Modal({ visible, onClose }: ModalProps) {
  // 监听ESC键关闭
  useEffect(() => {
    if (!visible) return;
    
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose?.();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    
    // 清理函数
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [visible, onClose]);
  
  return <>{/* Modal内容 */}</>;
}
```

## 样式接口点规范

### 类名约定

组件使用约定的类名作为样式接口点：

```typescript
function Button({ type, size, disabled, loading, children }: ButtonProps) {
  const className = classNames(
    'chips-button',                                    // 基础类
    `chips-button-${type}`,                           // 类型类
    `chips-button-${size}`,                           // 尺寸类
    {
      'chips-button-disabled': disabled,              // 状态类
      'chips-button-loading': loading,                // 状态类
    }
  );
  
  return (
    <button className={className}>
      {loading && <span className="chips-button-loading-icon" />}
      <span className="chips-button-content">{children}</span>
    </button>
  );
}
```

### 类名格式

遵循BEM命名规范的变体：

**格式**：`chips-[component]-[element]-[modifier]`

**示例**
- `chips-button`：组件基础类
- `chips-button-primary`：组件变体
- `chips-button-icon`：组件元素
- `chips-button-disabled`：组件状态

### CSS变量使用

组件不定义CSS变量值，只使用变量：

```css
/* ✅ 正确：组件样式使用变量 */
.chips-button {
  padding: var(--chips-button-padding);
  font-size: var(--chips-font-size-base);
  border-radius: var(--chips-border-radius);
  background-color: var(--chips-button-bg);
  color: var(--chips-button-color);
}

/* ❌ 错误：组件中不定义变量值 */
.chips-button {
  --chips-button-padding: 8px 16px;  /* ❌ 变量值由主题定义 */
  padding: var(--chips-button-padding);
}
```

### 自定义类名

支持用户传入自定义类名：

```typescript
function Button({ className: customClassName, ...props }: ButtonProps) {
  const className = classNames(
    'chips-button',
    `chips-button-${props.type}`,
    customClassName  // 追加自定义类名
  );
  
  return <button className={className}>...</button>;
}
```

## 性能优化规范

### 避免不必要的渲染

使用React.memo优化：

```typescript
export const Button = React.memo(function Button(props: ButtonProps) {
  // 组件实现
}, (prevProps, nextProps) => {
  // 自定义比较逻辑（可选）
  return prevProps.disabled === nextProps.disabled &&
         prevProps.loading === nextProps.loading &&
         prevProps.children === nextProps.children;
});
```

### useCallback缓存回调

```typescript
function Parent() {
  // ❌ 每次渲染都创建新函数
  const handleClick = () => {
    console.log('clicked');
  };
  
  // ✅ 缓存函数引用
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <Button onClick={handleClick} />;
}
```

### useMemo缓存计算结果

```typescript
function Table({ dataSource, sortConfig }: TableProps) {
  // 缓存排序结果
  const sortedData = useMemo(() => {
    return [...dataSource].sort((a, b) => {
      const { key, direction } = sortConfig;
      return direction === 'asc' 
        ? a[key] - b[key]
        : b[key] - a[key];
    });
  }, [dataSource, sortConfig]);
  
  return <>{/* 使用sortedData */}</>;
}
```

### 虚拟滚动

长列表使用虚拟滚动：

```typescript
function List({ dataSource, renderItem }: ListProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
  
  // 只渲染可见范围内的项
  const visibleItems = dataSource.slice(visibleRange.start, visibleRange.end);
  
  return (
    <div ref={containerRef} onScroll={handleScroll}>
      {visibleItems.map(renderItem)}
    </div>
  );
}
```

## 错误处理规范

### Props验证

在开发模式下验证Props：

```typescript
if (process.env.NODE_ENV === 'development') {
  if (!src) {
    console.error('Image组件必须提供src属性');
  }
  if (width && width < 0) {
    console.warn('Image组件的width不能为负数');
  }
}
```

### 错误边界

提供错误边界组件：

```typescript
class ErrorBoundary extends React.Component<Props, State> {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('组件错误:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>出错了</div>;
    }
    return this.props.children;
  }
}
```

### 降级处理

关键功能失败时提供降级方案：

```typescript
function Image({ src, fallback, alt }: ImageProps) {
  const [error, setError] = useState(false);
  
  if (error) {
    return fallback || <div className="chips-image-fallback">{alt}</div>;
  }
  
  return (
    <img 
      src={src} 
      alt={alt}
      onError={() => setError(true)}
    />
  );
}
```

## 测试规范

### 单元测试

每个组件都应有单元测试：

```typescript
describe('Button', () => {
  it('应该渲染默认按钮', () => {
    render(<Button>点击</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('点击');
  });
  
  it('应该处理点击事件', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>点击</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('禁用状态下不应触发点击', () => {
    const handleClick = jest.fn();
    render(<Button disabled onClick={handleClick}>点击</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).not.toHaveBeenCalled();
  });
});
```

### 快照测试

测试组件渲染结果：

```typescript
it('应该匹配快照', () => {
  const { container } = render(
    <Button type="primary" size="large">点击</Button>
  );
  expect(container.firstChild).toMatchSnapshot();
});
```

### 可访问性测试

测试无障碍性：

```typescript
it('应该符合无障碍标准', async () => {
  const { container } = render(<Button>点击</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

## 文档规范

### 组件文档结构

每个组件提供完整文档：

```markdown
# Button 按钮

按钮用于触发操作。

## 何时使用

- 标记一个（或封装一组）操作命令，响应用户点击行为
- 提交表单

## 代码示例

### 基础用法

\`\`\`tsx
<Button type="primary">主要按钮</Button>
<Button>默认按钮</Button>
<Button type="dashed">虚线按钮</Button>
<Button type="link">链接按钮</Button>
\`\`\`

### 禁用状态

\`\`\`tsx
<Button disabled>禁用按钮</Button>
\`\`\`

## API

### Button Props

| 参数 | 说明 | 类型 | 默认值 |
|------|------|------|--------|
| type | 按钮类型 | `'default' \| 'primary' \| 'dashed' \| 'link' \| 'text'` | `'default'` |
| size | 按钮尺寸 | `'small' \| 'medium' \| 'large'` | `'medium'` |
| disabled | 是否禁用 | `boolean` | `false` |
| loading | 是否加载中 | `boolean` | `false` |
| icon | 按钮图标 | `ReactNode` | - |
| onClick | 点击事件 | `(event: MouseEvent) => void` | - |

### 样式接口点

| 类名 | 说明 |
|------|------|
| `.chips-button` | 按钮容器 |
| `.chips-button-primary` | 主要按钮 |
| `.chips-button-disabled` | 禁用状态 |
| `.chips-button-loading` | 加载状态 |
| `.chips-button-icon` | 按钮图标 |
| `.chips-button-content` | 按钮文本 |
```

### 代码注释

关键代码添加注释：

```typescript
/**
 * 按钮组件
 * 
 * @example
 * ```tsx
 * <Button type="primary" onClick={handleClick}>
 *   点击我
 * </Button>
 * ```
 */
export function Button({
  type = 'default',
  size = 'medium',
  disabled = false,
  loading = false,
  icon,
  children,
  onClick,
  className,
  ...rest
}: ButtonProps) {
  // 合成类名
  const buttonClassName = classNames(
    'chips-button',
    `chips-button-${type}`,
    `chips-button-${size}`,
    {
      'chips-button-disabled': disabled || loading,
      'chips-button-loading': loading,
    },
    className
  );
  
  // 处理点击事件
  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    // 禁用或加载中时不触发点击
    if (disabled || loading) {
      event.preventDefault();
      return;
    }
    onClick?.(event);
  };
  
  return (
    <button
      className={buttonClassName}
      onClick={handleClick}
      disabled={disabled || loading}
      {...rest}
    >
      {loading && <LoadingIcon className="chips-button-loading-icon" />}
      {icon && <span className="chips-button-icon">{icon}</span>}
      <span className="chips-button-content">{children}</span>
    </button>
  );
}
```

## 总结

组件设计规范确保了组件库的一致性、可维护性和可扩展性。遵循这些规范，可以创建高质量、易用、性能优秀的组件。核心要点：

1. **功能与样式分离**：组件只包含功能和布局，样式由主题包提供
2. **清晰的Props接口**：类型安全、文档完整、默认值合理
3. **标准的事件处理**：命名规范、参数合理、行为可预期
4. **优秀的性能**：避免不必要的渲染、使用缓存、虚拟滚动
5. **完整的测试**：单元测试、快照测试、无障碍测试
6. **详细的文档**：API文档、示例代码、使用指南
