# 薯片组件库 - 与基础层集成

**版本**: 1.0.0  
**更新时间**: 2026-01-31

---

## 概述

薯片组件库基于公共基础层（Chips-Foundation）构建，通过微内核路由调用基础层的通用功能模块。本文档详细说明组件库如何与基础层集成，如何调用基础层的功能，以及集成的最佳实践。

---

## 1. 集成架构

### 1.1 架构层级

```
┌─────────────────────────────────────┐
│   组件库 (Chips-ComponentLibrary)    │
│   - 业务级UI组件                      │
│   - 布局组件                          │
│   - 卡片渲染组件                      │
└──────────────┬──────────────────────┘
               │ 通过Core.request()调用
               │
┌──────────────▼──────────────────────┐
│   微内核 (Chips-Core)                │
│   - 中心路由                          │
│   - 模块注册                          │
│   - 请求转发                          │
└──────────────┬──────────────────────┘
               │
               │ 路由到对应模块
               ▼
┌─────────────────────────────────────┐
│   基础层 (Chips-Foundation)          │
│   - UIControls (基础控件)            │
│   - DragDropSystem (拖拽系统)        │
│   - WindowManager (窗口管理)         │
│   - ImageViewer (图片查看)           │
│   - VideoPlayer (视频播放)           │
│   - AudioPlayer (音频播放)           │
│   - MarkdownParser (Markdown解析)   │
│   - CodeHighlighter (代码高亮)      │
│   - RichTextRenderer (富文本渲染)   │
│   - IFrameWrapper (网页框架)         │
│   - I18nSystem (多语言系统)          │
│   - ...                              │
└─────────────────────────────────────┘
```

### 1.2 核心原则

1. **所有调用通过内核路由**：不直接依赖基础层模块
2. **完全解耦**：组件库和基础层通过内核完全解耦
3. **不重复造轮子**：基础层已有的功能直接调用
4. **职责清晰**：组件库专注业务级UI，基础功能由基础层提供
5. **异步通信**：所有调用都是异步的

---

## 2. 调用方式

### 2.1 标准调用格式

```typescript
// 统一的请求格式
const response = await Core.request({
  target: '基础层模块名',
  action: '操作名称',
  params: { /* 参数对象 */ }
});

// 统一的响应格式
interface Response {
  success: boolean;
  data: any;
  error?: {
    code: string;
    message: string;
  };
}
```

### 2.2 调用示例

```typescript
// 示例1：调用VideoPlayer播放视频
const response = await Core.request({
  target: 'VideoPlayer',
  action: 'render',
  params: {
    container: this.containerElement,
    src: this.props.videoUrl,
    controls: true
  }
});

if (response.success) {
  console.log('视频加载成功', response.data);
} else {
  console.error('视频加载失败', response.error);
}

// 示例2：调用ImageViewer显示图片
const response = await Core.request({
  target: 'ImageViewer',
  action: 'display',
  params: {
    container: this.containerElement,
    src: this.props.imageUrl,
    fit: 'contain'
  }
});

// 示例3：调用DragDropSystem启用拖拽
await Core.request({
  target: 'DragDropSystem',
  action: 'enableDrag',
  params: {
    element: dragElement,
    options: {
      onDragStart: this.handleDragStart,
      onDrag: this.handleDrag,
      onDragEnd: this.handleDragEnd
    }
  }
});
```

### 2.3 错误处理

```typescript
try {
  const response = await Core.request({
    target: 'VideoPlayer',
    action: 'render',
    params: { /* ... */ }
  });
  
  if (!response.success) {
    // 处理业务错误
    console.error(`错误代码: ${response.error.code}`);
    console.error(`错误信息: ${response.error.message}`);
    // 显示用户友好的错误提示
    this.showError(response.error);
  }
} catch (error) {
  // 处理系统错误（网络错误、内核错误等）
  console.error('系统错误:', error);
  this.showSystemError();
}
```

---

## 3. 主要集成模块

### 3.1 UIControls 基础控件

**用途**：创建底层基础控件元素

**组件库使用场景**：
- Button组件：可选调用UIControls创建基础按钮元素
- Input组件：可选调用UIControls创建基础输入框
- 其他基础组件：在基础控件上添加业务功能

**API示例**：

```typescript
// 创建基础按钮
const response = await Core.request({
  target: 'UIControls',
  action: 'createButton',
  params: {
    text: '确定',
    type: 'primary'
  }
});

const buttonElement = response.data.element;

// 在组件中使用
class Button extends React.Component {
  async componentDidMount() {
    // 可选：使用基础层的按钮元素
    const baseButton = await this.createBaseButton();
    // 添加业务级功能
    this.attachBusinessLogic(baseButton);
  }
  
  async createBaseButton() {
    const response = await Core.request({
      target: 'UIControls',
      action: 'createButton',
      params: {
        text: this.props.children,
        type: this.props.type
      }
    });
    return response.data.element;
  }
}
```

**最佳实践**：
- Button、Input等简单组件可以不调用UIControls，直接使用HTML元素
- 复杂控件（如DatePicker）可以考虑调用UIControls
- 根据实际情况权衡是否调用基础层

### 3.2 DragDropSystem 拖拽系统

**用途**：处理拖拽操作

**组件库使用场景**：
- Tree组件：节点拖拽排序
- Table组件：列拖拽调整顺序
- Upload组件：文件拖拽上传
- 任何需要拖拽功能的组件

**API示例**：

```typescript
// 启用拖拽
await Core.request({
  target: 'DragDropSystem',
  action: 'enableDrag',
  params: {
    element: dragElement,
    options: {
      onDragStart: (event) => {
        console.log('开始拖拽', event);
      },
      onDrag: (event) => {
        console.log('拖拽中', event);
      },
      onDragEnd: (event) => {
        console.log('拖拽结束', event);
      }
    }
  }
});

// 设置拖放目标
await Core.request({
  target: 'DragDropSystem',
  action: 'enableDrop',
  params: {
    element: dropZone,
    options: {
      onDragOver: (event) => {
        event.preventDefault();
      },
      onDrop: (event) => {
        console.log('放置', event);
        this.handleDrop(event);
      }
    }
  }
});

// 禁用拖拽
await Core.request({
  target: 'DragDropSystem',
  action: 'disableDrag',
  params: { element: dragElement }
});
```

**Tree组件集成示例**：

```typescript
class Tree extends React.Component {
  async componentDidMount() {
    // 为所有树节点启用拖拽
    const nodes = this.containerRef.current.querySelectorAll('.tree-node');
    
    for (const node of nodes) {
      await Core.request({
        target: 'DragDropSystem',
        action: 'enableDrag',
        params: {
          element: node,
          options: {
            onDragStart: this.handleNodeDragStart,
            onDragEnd: this.handleNodeDragEnd
          }
        }
      });
    }
  }
  
  handleNodeDragStart = (event) => {
    const nodeId = event.target.dataset.nodeId;
    event.dataTransfer.setData('nodeId', nodeId);
  }
  
  handleNodeDragEnd = (event) => {
    // 更新节点顺序
    this.reorderNodes();
  }
}
```

### 3.3 WindowManager 窗口管理

**用途**：创建和管理窗口

**组件库使用场景**：
- Modal组件：创建模态对话框窗口
- Drawer组件：创建抽屉窗口
- 任何需要窗口管理的组件

**API示例**：

```typescript
// 创建模态窗口
const response = await Core.request({
  target: 'WindowManager',
  action: 'createWindow',
  params: {
    title: '确认对话框',
    content: contentElement,
    width: 600,
    height: 400,
    modal: true,
    closable: true
  }
});

const windowId = response.data.windowId;

// 关闭窗口
await Core.request({
  target: 'WindowManager',
  action: 'closeWindow',
  params: { windowId }
});

// 最小化窗口
await Core.request({
  target: 'WindowManager',
  action: 'minimizeWindow',
  params: { windowId }
});

// 最大化窗口
await Core.request({
  target: 'WindowManager',
  action: 'maximizeWindow',
  params: { windowId }
});
```

**Modal组件集成示例**：

```typescript
class Modal extends React.Component {
  windowId: string | null = null;
  
  async componentDidUpdate(prevProps) {
    if (this.props.visible && !prevProps.visible) {
      await this.createWindow();
    } else if (!this.props.visible && prevProps.visible) {
      await this.destroyWindow();
    }
  }
  
  async createWindow() {
    const response = await Core.request({
      target: 'WindowManager',
      action: 'createWindow',
      params: {
        title: this.props.title,
        content: this.renderContent(),
        width: this.props.width || 600,
        modal: true,
        closable: this.props.closable !== false,
        onClose: this.props.onCancel
      }
    });
    
    this.windowId = response.data.windowId;
  }
  
  async destroyWindow() {
    if (this.windowId) {
      await Core.request({
        target: 'WindowManager',
        action: 'closeWindow',
        params: { windowId: this.windowId }
      });
      this.windowId = null;
    }
  }
}
```

### 3.4 媒体组件集成

#### ImageViewer 图片查看器

**组件库使用场景**：
- ImageCard：渲染图片卡片
- Image组件：图片预览功能

```typescript
// ImageCard组件
class ImageCard extends React.Component {
  async renderImage() {
    await Core.request({
      target: 'ImageViewer',
      action: 'display',
      params: {
        container: this.containerRef.current,
        src: this.props.src,
        fit: this.props.fit || 'contain',
        alt: this.props.alt
      }
    });
  }
  
  async showPreview() {
    await Core.request({
      target: 'ImageViewer',
      action: 'preview',
      params: {
        src: this.props.src,
        fullscreen: true
      }
    });
  }
}
```

#### VideoPlayer 视频播放器

**组件库使用场景**：
- VideoCard：渲染视频卡片

```typescript
// VideoCard组件
class VideoCard extends React.Component {
  async renderVideo() {
    const response = await Core.request({
      target: 'VideoPlayer',
      action: 'render',
      params: {
        container: this.containerRef.current,
        src: this.props.src,
        poster: this.props.poster,
        controls: this.props.controls !== false,
        autoplay: this.props.autoplay || false
      }
    });
    
    this.playerId = response.data.playerId;
  }
  
  async play() {
    await Core.request({
      target: 'VideoPlayer',
      action: 'play',
      params: { playerId: this.playerId }
    });
  }
  
  async pause() {
    await Core.request({
      target: 'VideoPlayer',
      action: 'pause',
      params: { playerId: this.playerId }
    });
  }
}
```

#### AudioPlayer 音频播放器

**组件库使用场景**：
- AudioCard：渲染音频卡片

```typescript
// AudioCard组件
class AudioCard extends React.Component {
  async renderAudio() {
    const response = await Core.request({
      target: 'AudioPlayer',
      action: 'render',
      params: {
        container: this.containerRef.current,
        src: this.props.src,
        title: this.props.title,
        artist: this.props.artist,
        cover: this.props.cover
      }
    });
    
    this.playerId = response.data.playerId;
  }
}
```

### 3.5 文本组件集成

#### MarkdownParser Markdown解析器

**组件库使用场景**：
- MarkdownCard：解析和渲染Markdown内容

```typescript
// MarkdownCard组件
class MarkdownCard extends React.Component {
  async renderMarkdown() {
    // 解析Markdown
    const parseResponse = await Core.request({
      target: 'MarkdownParser',
      action: 'parse',
      params: {
        content: this.props.content,
        options: {
          breaks: true,
          linkify: true,
          typographer: true
        }
      }
    });
    
    const html = parseResponse.data.html;
    
    // 渲染HTML
    this.containerRef.current.innerHTML = html;
    
    // 代码高亮
    await this.highlightCode();
  }
  
  async highlightCode() {
    const codeBlocks = this.containerRef.current.querySelectorAll('pre code');
    
    for (const block of codeBlocks) {
      const language = block.className.replace('language-', '');
      const code = block.textContent;
      
      const response = await Core.request({
        target: 'CodeHighlighter',
        action: 'highlight',
        params: { code, language }
      });
      
      block.innerHTML = response.data.html;
    }
  }
}
```

#### CodeHighlighter 代码高亮器

**组件库使用场景**：
- CodeBlockCard：代码块卡片
- MarkdownCard：Markdown中的代码块

```typescript
// CodeBlockCard组件
class CodeBlockCard extends React.Component {
  async renderCode() {
    const response = await Core.request({
      target: 'CodeHighlighter',
      action: 'highlight',
      params: {
        code: this.props.code,
        language: this.props.language,
        showLineNumbers: this.props.showLineNumbers
      }
    });
    
    this.containerRef.current.innerHTML = response.data.html;
  }
}
```

#### RichTextRenderer 富文本渲染器

**组件库使用场景**：
- RichTextCard：渲染富文本内容

```typescript
// RichTextCard组件
class RichTextCard extends React.Component {
  async renderRichText() {
    const response = await Core.request({
      target: 'RichTextRenderer',
      action: 'render',
      params: {
        container: this.containerRef.current,
        content: this.props.content,
        format: 'html' // 或 'delta'
      }
    });
  }
}
```

### 3.6 IFrameWrapper 网页框架

**组件库使用场景**：
- WebpageCard：嵌入网页内容

```typescript
// WebpageCard组件
class WebpageCard extends React.Component {
  async renderWebpage() {
    const response = await Core.request({
      target: 'IFrameWrapper',
      action: 'create',
      params: {
        container: this.containerRef.current,
        url: this.props.url,
        sandbox: true,
        allowScripts: this.props.allowScripts || false
      }
    });
    
    this.iframeId = response.data.iframeId;
  }
}
```

### 3.7 I18nSystem 多语言系统

**组件库使用场景**：
- 所有组件：文本多语言显示

```typescript
// 获取翻译文本
const response = await Core.request({
  target: 'I18nSystem',
  action: 'translate',
  params: {
    code: 'i18n.ui.100001', // 系统词汇编码
    vars: { count: 10 }      // 变量
  }
});

const text = response.data.text; // 翻译后的文本

// 在组件中使用
class Button extends React.Component {
  async getButtonText() {
    const response = await Core.request({
      target: 'I18nSystem',
      action: 'translate',
      params: { code: this.props.textCode }
    });
    return response.data.text;
  }
  
  async render() {
    const text = await this.getButtonText();
    return <button>{text}</button>;
  }
}
```

**最佳实践**：
- 组件库应该提供封装好的多语言Hook或工具函数
- 开发时使用key，打包时自动替换为编码
- 参考[多语言系统规范](../../生态共用/11-多语言系统规范.md)

---

## 4. 集成最佳实践

### 4.1 何时调用基础层

**应该调用基础层的场景**：

1. **功能已存在**：基础层已经实现了该功能
2. **复杂功能**：功能实现复杂，如视频播放、代码高亮
3. **底层能力**：需要底层系统能力，如窗口管理、拖拽系统
4. **共享功能**：多个组件都需要的通用功能

**可以不调用基础层的场景**：

1. **简单UI**：简单的UI渲染，如Button、Input
2. **业务特定**：组件库特有的业务逻辑
3. **性能考虑**：调用开销大于自己实现

### 4.2 封装调用

**不推荐**：在组件中直接调用Core.request

```typescript
// ❌ 不推荐：直接在组件中调用
class VideoCard extends React.Component {
  async componentDidMount() {
    const response = await Core.request({
      target: 'VideoPlayer',
      action: 'render',
      params: { /* ... */ }
    });
  }
}
```

**推荐**：封装为专用的服务或Hook

```typescript
// ✅ 推荐：封装为服务
class VideoPlayerService {
  static async render(container, options) {
    const response = await Core.request({
      target: 'VideoPlayer',
      action: 'render',
      params: { container, ...options }
    });
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data;
  }
  
  static async play(playerId) {
    await Core.request({
      target: 'VideoPlayer',
      action: 'play',
      params: { playerId }
    });
  }
}

// 在组件中使用
class VideoCard extends React.Component {
  async componentDidMount() {
    this.playerData = await VideoPlayerService.render(
      this.containerRef.current,
      { src: this.props.src }
    );
  }
}

// 或封装为Hook（React）
function useVideoPlayer(containerRef, src) {
  const [playerId, setPlayerId] = useState(null);
  
  useEffect(() => {
    if (containerRef.current && src) {
      VideoPlayerService.render(containerRef.current, { src })
        .then(data => setPlayerId(data.playerId));
    }
  }, [containerRef, src]);
  
  const play = useCallback(() => {
    if (playerId) {
      VideoPlayerService.play(playerId);
    }
  }, [playerId]);
  
  return { playerId, play };
}
```

### 4.3 错误处理

```typescript
// 统一的错误处理封装
class BaseLayerService {
  static async call(target, action, params) {
    try {
      const response = await Core.request({ target, action, params });
      
      if (!response.success) {
        // 记录日志
        console.error(`基础层调用失败: ${target}.${action}`, response.error);
        
        // 抛出友好的错误
        throw new BaseLayerError(
          response.error.code,
          response.error.message,
          { target, action, params }
        );
      }
      
      return response.data;
    } catch (error) {
      // 处理系统错误
      console.error('基础层调用异常:', error);
      throw error;
    }
  }
}

// 使用
class VideoCard extends React.Component {
  async renderVideo() {
    try {
      const data = await BaseLayerService.call(
        'VideoPlayer',
        'render',
        { container: this.containerRef.current, src: this.props.src }
      );
      this.playerId = data.playerId;
    } catch (error) {
      // 显示错误UI
      this.setState({ error: error.message });
    }
  }
}
```

### 4.4 资源清理

```typescript
class VideoCard extends React.Component {
  playerId: string | null = null;
  
  async componentWillUnmount() {
    // 清理资源
    if (this.playerId) {
      await Core.request({
        target: 'VideoPlayer',
        action: 'destroy',
        params: { playerId: this.playerId }
      });
      this.playerId = null;
    }
  }
}
```

---

## 5. 性能优化

### 5.1 批量调用

```typescript
// ❌ 不推荐：多次调用
for (const node of nodes) {
  await Core.request({
    target: 'DragDropSystem',
    action: 'enableDrag',
    params: { element: node }
  });
}

// ✅ 推荐：批量调用
await Core.request({
  target: 'DragDropSystem',
  action: 'enableDragBatch',
  params: { elements: nodes }
});
```

### 5.2 缓存结果

```typescript
// 缓存翻译结果
const translationCache = new Map();

async function translate(code) {
  if (translationCache.has(code)) {
    return translationCache.get(code);
  }
  
  const response = await Core.request({
    target: 'I18nSystem',
    action: 'translate',
    params: { code }
  });
  
  translationCache.set(code, response.data.text);
  return response.data.text;
}
```

### 5.3 懒加载

```typescript
// 懒加载基础层模块
class VideoCard extends React.Component {
  async loadVideoPlayer() {
    // 第一次使用时才加载VideoPlayer模块
    if (!this.videoPlayerLoaded) {
      await Core.request({
        target: 'VideoPlayer',
        action: 'initialize',
        params: {}
      });
      this.videoPlayerLoaded = true;
    }
  }
}
```

---

## 6. 测试

### 6.1 Mock基础层调用

```typescript
// 测试时mock Core.request
jest.mock('@chips/core', () => ({
  Core: {
    request: jest.fn()
  }
}));

// 在测试中设置返回值
test('VideoCard渲染视频', async () => {
  Core.request.mockResolvedValue({
    success: true,
    data: { playerId: 'test-player-1' }
  });
  
  const { container } = render(<VideoCard src="test.mp4" />);
  
  await waitFor(() => {
    expect(Core.request).toHaveBeenCalledWith({
      target: 'VideoPlayer',
      action: 'render',
      params: expect.objectContaining({ src: 'test.mp4' })
    });
  });
});
```

### 6.2 集成测试

```typescript
// 端到端测试（实际调用基础层）
test('VideoCard完整播放流程', async () => {
  // 不mock，实际调用基础层
  const { container } = render(<VideoCard src="test.mp4" />);
  
  // 等待视频加载
  await waitFor(() => {
    expect(container.querySelector('video')).toBeInTheDocument();
  });
  
  // 测试播放
  const playButton = container.querySelector('.play-button');
  fireEvent.click(playButton);
  
  // 验证视频正在播放
  await waitFor(() => {
    expect(container.querySelector('video').paused).toBe(false);
  });
});
```

---

## 7. 总结

组件库通过微内核路由调用公共基础层的通用功能，实现以下目标：

1. **避免重复实现**：复用基础层的通用功能
2. **职责清晰**：组件库专注业务级UI
3. **完全解耦**：通过内核路由解耦
4. **标准接口**：统一的请求响应格式

**集成原则**：
- 所有调用通过Core.request
- 封装调用为服务或Hook
- 统一错误处理
- 注意资源清理
- 优化性能
- 完善测试

**主要集成模块**：
- UIControls：基础控件（可选）
- DragDropSystem：拖拽功能
- WindowManager：窗口管理
- 媒体组件：ImageViewer、VideoPlayer、AudioPlayer
- 文本组件：MarkdownParser、CodeHighlighter、RichTextRenderer
- IFrameWrapper：网页嵌入
- I18nSystem：多语言支持

通过合理的集成架构和最佳实践，组件库可以充分利用基础层的能力，同时保持代码的清晰和可维护性。

---

**维护团队**: 薯片生态核心团队  
**最后更新**: 2026-01-31
