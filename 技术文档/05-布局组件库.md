# 布局组件库设计

## 概述

布局组件提供页面的整体结构和空间组织，是构建界面布局的核心工具。本文档说明核心布局组件的设计实现。

> **重要说明**：箱子布局（如瀑布流布局、网格布局、时间线布局等）的**具体实现在布局插件中**，而不是在组件库中。布局插件提供完整的前端代码，最终交付一个 iframe 窗口。组件库只提供 `BoxLayoutView` 组件作为 iframe 的占位/转接口。

## BoxLayoutView 箱子布局视图（iframe 容器）

### 设计说明

`BoxLayoutView` 是一个 iframe 容器组件，用于显示箱子布局插件渲染的内容。箱子布局插件（如瀑布流、网格、时间线等）提供完整的前端实现，通过 iframe 隔离渲染。开发者只需使用这个组件，即可显示对应布局插件的 iframe 窗口。

```
┌─────────────────────────────────────────────────────────────┐
│                    箱子布局插件                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  完整的前端代码（HTML + CSS + JS）                   │   │
│  │  • 瀑布流布局插件                                    │   │
│  │  • 网格布局插件                                      │   │
│  │  • 时间线布局插件                                    │   │
│  │  • 书架布局插件                                      │   │
│  │  • ...                                              │   │
│  └───────────────────────┬─────────────────────────────┘   │
│                          │ 输出 iframe                      │
└──────────────────────────┼──────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────────┐
│           薯片组件库 - BoxLayoutView 组件                    │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  iframe 容器组件（占位/转接口）                         │ │
│  │  • 接收布局插件 ID                                     │ │
│  │  • 接收箱子数据                                        │ │
│  │  • 管理 iframe 通信                                    │ │
│  │  • 处理加载状态和错误                                  │ │
│  └────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### 组件设计

```vue
<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';

interface BoxLayoutViewProps {
  /** 布局插件ID */
  layoutPluginId: string;
  /** 箱子ID */
  boxId: string;
  /** 箱子数据 */
  boxData?: BoxData;
  /** 主题包标识 */
  theme?: string;
  /** iframe 宽度 */
  width?: string | number;
  /** iframe 高度 */
  height?: string | number;
  /** 是否可编辑 */
  editable?: boolean;
}

interface BoxData {
  cards: CardItem[];
  layoutConfig: Record<string, any>;
  metadata?: Record<string, any>;
}

const props = withDefaults(defineProps<BoxLayoutViewProps>(), {
  width: '100%',
  height: '100%',
  editable: false
});

const emit = defineEmits<{
  load: [];
  error: [error: Error];
  cardClick: [cardId: string];
  layoutChange: [config: Record<string, any>];
}>();

// 状态
const iframeRef = ref<HTMLIFrameElement | null>(null);
const loading = ref(true);
const error = ref<Error | null>(null);
const iframeSrc = ref('');

// 计算 iframe URL
const computeIframeSrc = async () => {
  try {
    // 通过内核获取布局插件的 iframe URL
    const response = await Core.request({
      target: 'PluginManager',
      action: 'getLayoutIframeUrl',
      params: {
        pluginId: props.layoutPluginId,
        boxId: props.boxId,
        theme: props.theme,
        editable: props.editable
      }
    });
    iframeSrc.value = response.data.url;
  } catch (e) {
    error.value = e as Error;
    emit('error', e as Error);
  }
};

// iframe 加载完成
const handleLoad = () => {
  loading.value = false;
  emit('load');
  
  // 向 iframe 发送初始数据
  sendDataToIframe();
};

// iframe 加载错误
const handleError = (e: Event) => {
  loading.value = false;
  const err = new Error('Failed to load layout plugin');
  error.value = err;
  emit('error', err);
};

// 向 iframe 发送数据
const sendDataToIframe = () => {
  if (iframeRef.value?.contentWindow && props.boxData) {
    iframeRef.value.contentWindow.postMessage({
      type: 'CHIPS_BOX_DATA',
      payload: {
        boxId: props.boxId,
        boxData: props.boxData,
        theme: props.theme,
        editable: props.editable
      }
    }, '*');
  }
};

// 监听 iframe 消息
const handleMessage = (event: MessageEvent) => {
  if (event.source !== iframeRef.value?.contentWindow) return;
  
  const { type, payload } = event.data;
  
  switch (type) {
    case 'CHIPS_CARD_CLICK':
      emit('cardClick', payload.cardId);
      break;
    case 'CHIPS_LAYOUT_CHANGE':
      emit('layoutChange', payload.config);
      break;
    case 'CHIPS_REQUEST_DATA':
      sendDataToIframe();
      break;
  }
};

// 生命周期
onMounted(() => {
  computeIframeSrc();
  window.addEventListener('message', handleMessage);
});

onUnmounted(() => {
  window.removeEventListener('message', handleMessage);
});

// 监听数据变化
watch(() => props.boxData, () => {
  sendDataToIframe();
}, { deep: true });
</script>

<template>
  <div
    :class="[
      'chips-box-layout-view',
      { 'chips-box-layout-view--loading': loading },
      { 'chips-box-layout-view--error': error }
    ]"
  >
    <!-- 加载状态 -->
    <div v-if="loading" class="chips-box-layout-view__loading">
      <slot name="loading">
        <span class="chips-box-layout-view__spinner" />
      </slot>
    </div>
    
    <!-- 错误状态 -->
    <div v-if="error" class="chips-box-layout-view__error">
      <slot name="error" :error="error">
        <span class="chips-box-layout-view__error-message">
          {{ error.message }}
        </span>
      </slot>
    </div>
    
    <!-- iframe 容器 -->
    <iframe
      v-show="!loading && !error"
      ref="iframeRef"
      :src="iframeSrc"
      :style="{
        width: typeof width === 'number' ? `${width}px` : width,
        height: typeof height === 'number' ? `${height}px` : height
      }"
      class="chips-box-layout-view__iframe"
      frameborder="0"
      sandbox="allow-scripts allow-same-origin"
      @load="handleLoad"
      @error="handleError"
    />
  </div>
</template>
```

### 样式接口点

```css
.chips-box-layout-view {
  /* 容器 */
}

.chips-box-layout-view--loading {
  /* 加载中状态 */
}

.chips-box-layout-view--error {
  /* 错误状态 */
}

.chips-box-layout-view__loading {
  /* 加载占位区域 */
}

.chips-box-layout-view__spinner {
  /* 加载动画 */
}

.chips-box-layout-view__error {
  /* 错误显示区域 */
}

.chips-box-layout-view__error-message {
  /* 错误信息 */
}

.chips-box-layout-view__iframe {
  /* iframe 元素 */
}
```

### 使用示例

```vue
<script setup>
import { BoxLayoutView } from '@chips/components';

const boxData = {
  cards: [...],
  layoutConfig: { columns: 3, gap: 16 }
};

const handleCardClick = (cardId: string) => {
  // 打开卡片详情
};
</script>

<template>
  <!-- 显示瀑布流布局 -->
  <BoxLayoutView
    layout-plugin-id="chips:waterfall-layout"
    box-id="box-123"
    :box-data="boxData"
    theme="default"
    height="600px"
    @card-click="handleCardClick"
  />
</template>
```

### 箱子布局插件列表

具体的箱子布局实现在各自的插件中：

| 布局类型 | 插件ID | 说明 |
|---------|--------|------|
| 列表布局 | chips:list-layout | 垂直或水平列表 |
| 网格布局 | chips:grid-layout | 固定网格排列 |
| 瀑布流布局 | chips:waterfall-layout | 瀑布流算法排列 |
| 无限桌面 | chips:canvas-layout | 自由摆放画布 |
| 时间线布局 | chips:timeline-layout | 按时间排列 |
| 书架布局 | chips:bookshelf-layout | 模拟书架展示 |
| 朋友圈布局 | chips:moments-layout | 社交动态流 |
| 个人主页空间 | chips:profile-layout | 个人主页区块 |

详见 [插件开发规范 - 布局插件开发](../../生态共用/07-插件开发规范.md)。

---

## Grid 栅格系统

### 组件设计

```typescript
// Row组件
interface RowProps {
  gutter?: number | [number, number];
  justify?: 'start' | 'end' | 'center' | 'space-around' | 'space-between';
  align?: 'top' | 'middle' | 'bottom';
  wrap?: boolean;
  children?: ReactNode;
  className?: string;
}

export function Row({
  gutter = 0,
  justify = 'start',
  align = 'top',
  wrap = true,
  children,
  className,
}: RowProps) {
  const [horizontalGutter, verticalGutter] = Array.isArray(gutter)
    ? gutter
    : [gutter, 0];
  
  const rowStyle: CSSProperties = {
    marginLeft: horizontalGutter ? -horizontalGutter / 2 : undefined,
    marginRight: horizontalGutter ? -horizontalGutter / 2 : undefined,
    marginTop: verticalGutter ? -verticalGutter / 2 : undefined,
    marginBottom: verticalGutter ? -verticalGutter / 2 : undefined,
  };
  
  const rowClassName = classNames(
    'chips-row',
    `chips-row-justify-${justify}`,
    `chips-row-align-${align}`,
    {
      'chips-row-nowrap': !wrap,
    },
    className
  );
  
  return (
    <div className={rowClassName} style={rowStyle}>
      {React.Children.map(children, child => {
        if (React.isValidElement(child)) {
          return React.cloneElement(child, {
            ...child.props,
            gutter: [horizontalGutter, verticalGutter],
          } as any);
        }
        return child;
      })}
    </div>
  );
}

// Col组件
interface ColProps {
  span?: number;
  offset?: number;
  push?: number;
  pull?: number;
  xs?: number | ColSize;
  sm?: number | ColSize;
  md?: number | ColSize;
  lg?: number | ColSize;
  xl?: number | ColSize;
  children?: ReactNode;
  className?: string;
  gutter?: [number, number];
}

interface ColSize {
  span?: number;
  offset?: number;
  push?: number;
  pull?: number;
}

export function Col({
  span,
  offset,
  push,
  pull,
  xs,
  sm,
  md,
  lg,
  xl,
  children,
  className,
  gutter = [0, 0],
}: ColProps) {
  const [horizontalGutter, verticalGutter] = gutter;
  
  const colStyle: CSSProperties = {
    paddingLeft: horizontalGutter ? horizontalGutter / 2 : undefined,
    paddingRight: horizontalGutter ? horizontalGutter / 2 : undefined,
    paddingTop: verticalGutter ? verticalGutter / 2 : undefined,
    paddingBottom: verticalGutter ? verticalGutter / 2 : undefined,
  };
  
  const colClassName = classNames(
    'chips-col',
    span && `chips-col-${span}`,
    offset && `chips-col-offset-${offset}`,
    push && `chips-col-push-${push}`,
    pull && `chips-col-pull-${pull}`,
    xs && `chips-col-xs-${typeof xs === 'number' ? xs : xs.span}`,
    sm && `chips-col-sm-${typeof sm === 'number' ? sm : sm.span}`,
    md && `chips-col-md-${typeof md === 'number' ? md : md.span}`,
    lg && `chips-col-lg-${typeof lg === 'number' ? lg : lg.span}`,
    xl && `chips-col-xl-${typeof xl === 'number' ? xl : xl.span}`,
    className
  );
  
  return (
    <div className={colClassName} style={colStyle}>
      {children}
    </div>
  );
}
```

### 样式实现

```css
.chips-row {
  display: flex;
  flex-wrap: wrap;
}

.chips-row-nowrap {
  flex-wrap: nowrap;
}

.chips-row-justify-start {
  justify-content: flex-start;
}

.chips-row-justify-end {
  justify-content: flex-end;
}

.chips-row-justify-center {
  justify-content: center;
}

.chips-row-justify-space-around {
  justify-content: space-around;
}

.chips-row-justify-space-between {
  justify-content: space-between;
}

.chips-row-align-top {
  align-items: flex-start;
}

.chips-row-align-middle {
  align-items: center;
}

.chips-row-align-bottom {
  align-items: flex-end;
}

.chips-col {
  flex: 0 0 auto;
}

/* 24栅格系统 */
.chips-col-1 { width: 4.166666667%; }
.chips-col-2 { width: 8.333333333%; }
.chips-col-3 { width: 12.5%; }
.chips-col-4 { width: 16.666666667%; }
.chips-col-5 { width: 20.833333333%; }
.chips-col-6 { width: 25%; }
.chips-col-7 { width: 29.166666667%; }
.chips-col-8 { width: 33.333333333%; }
.chips-col-9 { width: 37.5%; }
.chips-col-10 { width: 41.666666667%; }
.chips-col-11 { width: 45.833333333%; }
.chips-col-12 { width: 50%; }
.chips-col-13 { width: 54.166666667%; }
.chips-col-14 { width: 58.333333333%; }
.chips-col-15 { width: 62.5%; }
.chips-col-16 { width: 66.666666667%; }
.chips-col-17 { width: 70.833333333%; }
.chips-col-18 { width: 75%; }
.chips-col-19 { width: 79.166666667%; }
.chips-col-20 { width: 83.333333333%; }
.chips-col-21 { width: 87.5%; }
.chips-col-22 { width: 91.666666667%; }
.chips-col-23 { width: 95.833333333%; }
.chips-col-24 { width: 100%; }

/* 响应式断点 */
@media (max-width: 575px) {
  .chips-col-xs-12 { width: 50%; }
  .chips-col-xs-24 { width: 100%; }
}

@media (min-width: 576px) {
  .chips-col-sm-12 { width: 50%; }
  .chips-col-sm-24 { width: 100%; }
}

@media (min-width: 768px) {
  .chips-col-md-12 { width: 50%; }
  .chips-col-md-24 { width: 100%; }
}

@media (min-width: 992px) {
  .chips-col-lg-12 { width: 50%; }
  .chips-col-lg-24 { width: 100%; }
}

@media (min-width: 1200px) {
  .chips-col-xl-12 { width: 50%; }
  .chips-col-xl-24 { width: 100%; }
}
```

## Flex 弹性布局

### 组件设计

```typescript
interface FlexProps {
  direction?: 'row' | 'row-reverse' | 'column' | 'column-reverse';
  justify?: 'start' | 'end' | 'center' | 'space-between' | 'space-around' | 'space-evenly';
  align?: 'start' | 'end' | 'center' | 'stretch' | 'baseline';
  wrap?: 'nowrap' | 'wrap' | 'wrap-reverse';
  gap?: number | string;
  children?: ReactNode;
  className?: string;
}

export function Flex({
  direction = 'row',
  justify = 'start',
  align = 'start',
  wrap = 'wrap',
  gap,
  children,
  className,
}: FlexProps) {
  const flexClassName = classNames(
    'chips-flex',
    `chips-flex-${direction}`,
    `chips-flex-justify-${justify}`,
    `chips-flex-align-${align}`,
    `chips-flex-${wrap}`,
    className
  );
  
  const flexStyle: CSSProperties = gap ? { gap } : undefined;
  
  return (
    <div className={flexClassName} style={flexStyle}>
      {children}
    </div>
  );
}
```

### 样式实现

```css
.chips-flex {
  display: flex;
}

.chips-flex-row {
  flex-direction: row;
}

.chips-flex-row-reverse {
  flex-direction: row-reverse;
}

.chips-flex-column {
  flex-direction: column;
}

.chips-flex-column-reverse {
  flex-direction: column-reverse;
}

.chips-flex-justify-start {
  justify-content: flex-start;
}

.chips-flex-justify-end {
  justify-content: flex-end;
}

.chips-flex-justify-center {
  justify-content: center;
}

.chips-flex-justify-space-between {
  justify-content: space-between;
}

.chips-flex-justify-space-around {
  justify-content: space-around;
}

.chips-flex-justify-space-evenly {
  justify-content: space-evenly;
}

.chips-flex-align-start {
  align-items: flex-start;
}

.chips-flex-align-end {
  align-items: flex-end;
}

.chips-flex-align-center {
  align-items: center;
}

.chips-flex-align-stretch {
  align-items: stretch;
}

.chips-flex-align-baseline {
  align-items: baseline;
}

.chips-flex-nowrap {
  flex-wrap: nowrap;
}

.chips-flex-wrap {
  flex-wrap: wrap;
}

.chips-flex-wrap-reverse {
  flex-wrap: wrap-reverse;
}
```

## Container 容器

### 组件设计

```typescript
interface ContainerProps {
  maxWidth?: number | string | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | false;
  padding?: number | string;
  centered?: boolean;
  children?: ReactNode;
  className?: string;
}

const containerMaxWidths = {
  xs: 480,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
};

export function Container({
  maxWidth = 'lg',
  padding,
  centered = true,
  children,
  className,
}: ContainerProps) {
  const containerClassName = classNames(
    'chips-container',
    maxWidth && typeof maxWidth === 'string' && `chips-container-${maxWidth}`,
    {
      'chips-container-centered': centered,
    },
    className
  );
  
  const containerStyle: CSSProperties = {};
  
  if (maxWidth && typeof maxWidth !== 'boolean') {
    containerStyle.maxWidth = typeof maxWidth === 'number' || !isNaN(Number(maxWidth))
      ? maxWidth
      : containerMaxWidths[maxWidth as keyof typeof containerMaxWidths];
  }
  
  if (padding) {
    containerStyle.padding = padding;
  }
  
  return (
    <div className={containerClassName} style={containerStyle}>
      {children}
    </div>
  );
}
```

## Layout 页面布局

### 组件设计

```typescript
interface LayoutProps {
  children?: ReactNode;
  className?: string;
}

export function Layout({ children, className }: LayoutProps) {
  return (
    <div className={classNames('chips-layout', className)}>
      {children}
    </div>
  );
}

interface HeaderProps {
  children?: ReactNode;
  className?: string;
}

export function Header({ children, className }: HeaderProps) {
  return (
    <header className={classNames('chips-layout-header', className)}>
      {children}
    </header>
  );
}

interface SiderProps {
  width?: number | string;
  collapsible?: boolean;
  collapsed?: boolean;
  onCollapse?: (collapsed: boolean) => void;
  children?: ReactNode;
  className?: string;
}

export function Sider({
  width = 200,
  collapsible = false,
  collapsed = false,
  onCollapse,
  children,
  className,
}: SiderProps) {
  const siderClassName = classNames(
    'chips-layout-sider',
    {
      'chips-layout-sider-collapsed': collapsed,
    },
    className
  );
  
  const siderStyle: CSSProperties = {
    width: collapsed ? 80 : width,
  };
  
  return (
    <aside className={siderClassName} style={siderStyle}>
      {children}
      {collapsible && (
        <button
          className="chips-layout-sider-trigger"
          onClick={() => onCollapse?.(!collapsed)}
        >
          {collapsed ? <RightIcon /> : <LeftIcon />}
        </button>
      )}
    </aside>
  );
}

interface ContentProps {
  children?: ReactNode;
  className?: string;
}

export function Content({ children, className }: ContentProps) {
  return (
    <main className={classNames('chips-layout-content', className)}>
      {children}
    </main>
  );
}

interface FooterProps {
  children?: ReactNode;
  className?: string;
}

export function Footer({ children, className }: FooterProps) {
  return (
    <footer className={classNames('chips-layout-footer', className)}>
      {children}
    </footer>
  );
}

// 组合导出
Layout.Header = Header;
Layout.Sider = Sider;
Layout.Content = Content;
Layout.Footer = Footer;
```

### 使用示例

```typescript
<Layout>
  <Header>顶部导航</Header>
  <Layout>
    <Sider collapsible>侧边栏</Sider>
    <Content>主内容区</Content>
  </Layout>
  <Footer>底部信息</Footer>
</Layout>
```

## Space 间距

### 组件设计

```typescript
interface SpaceProps {
  size?: number | 'small' | 'medium' | 'large' | [number, number];
  direction?: 'horizontal' | 'vertical';
  align?: 'start' | 'end' | 'center' | 'baseline';
  wrap?: boolean;
  split?: ReactNode;
  children?: ReactNode;
  className?: string;
}

const spaceSize = {
  small: 8,
  medium: 16,
  large: 24,
};

export function Space({
  size = 'medium',
  direction = 'horizontal',
  align,
  wrap = false,
  split,
  children,
  className,
}: SpaceProps) {
  const items = React.Children.toArray(children);
  
  const [horizontalSize, verticalSize] = Array.isArray(size)
    ? size
    : [
        typeof size === 'number' ? size : spaceSize[size],
        typeof size === 'number' ? size : spaceSize[size],
      ];
  
  const spaceClassName = classNames(
    'chips-space',
    `chips-space-${direction}`,
    align && `chips-space-align-${align}`,
    {
      'chips-space-wrap': wrap,
    },
    className
  );
  
  const spaceStyle: CSSProperties = {
    gap: direction === 'horizontal' 
      ? `${verticalSize}px ${horizontalSize}px`
      : `${verticalSize}px ${horizontalSize}px`,
  };
  
  return (
    <div className={spaceClassName} style={spaceStyle}>
      {items.map((item, index) => (
        <React.Fragment key={index}>
          <div className="chips-space-item">{item}</div>
          {split && index < items.length - 1 && (
            <div className="chips-space-split">{split}</div>
          )}
        </React.Fragment>
      ))}
    </div>
  );
}
```

## Card 卡片容器

### 组件设计

```typescript
interface CardProps {
  title?: ReactNode;
  extra?: ReactNode;
  bordered?: boolean;
  hoverable?: boolean;
  loading?: boolean;
  cover?: ReactNode;
  children?: ReactNode;
  className?: string;
}

export function Card({
  title,
  extra,
  bordered = true,
  hoverable = false,
  loading = false,
  cover,
  children,
  className,
}: CardProps) {
  const cardClassName = classNames(
    'chips-card',
    {
      'chips-card-bordered': bordered,
      'chips-card-hoverable': hoverable,
      'chips-card-loading': loading,
    },
    className
  );
  
  return (
    <div className={cardClassName}>
      {cover && <div className="chips-card-cover">{cover}</div>}
      {(title || extra) && (
        <div className="chips-card-head">
          {title && <div className="chips-card-title">{title}</div>}
          {extra && <div className="chips-card-extra">{extra}</div>}
        </div>
      )}
      <div className="chips-card-body">
        {loading ? <Loading /> : children}
      </div>
    </div>
  );
}
```

### 样式实现

```css
.chips-card {
  background-color: var(--chips-color-bg-base);
  border-radius: var(--chips-border-radius-base);
  overflow: hidden;
  transition: var(--chips-transition-base);
}

.chips-card-bordered {
  border: 1px solid var(--chips-color-border);
}

.chips-card-hoverable:hover {
  box-shadow: var(--chips-shadow-lg);
  transform: translateY(-2px);
}

.chips-card-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--chips-spacing-md);
  border-bottom: 1px solid var(--chips-color-border);
}

.chips-card-title {
  font-size: var(--chips-font-size-lg);
  font-weight: var(--chips-font-weight-medium);
  color: var(--chips-color-text-primary);
}

.chips-card-body {
  padding: var(--chips-spacing-md);
}
```

## Collapse 折叠面板

### 组件设计

```typescript
interface CollapseProps {
  activeKey?: string | string[];
  defaultActiveKey?: string | string[];
  accordion?: boolean;
  onChange?: (key: string | string[]) => void;
  children?: ReactNode;
  className?: string;
}

interface CollapsePanelProps {
  key: string;
  header: ReactNode;
  disabled?: boolean;
  children?: ReactNode;
}

export function Collapse({
  activeKey: controlledActiveKey,
  defaultActiveKey,
  accordion = false,
  onChange,
  children,
  className,
}: CollapseProps) {
  const isControlled = controlledActiveKey !== undefined;
  const [internalActiveKey, setInternalActiveKey] = useState<string | string[]>(
    defaultActiveKey || (accordion ? '' : [])
  );
  
  const activeKey = isControlled ? controlledActiveKey : internalActiveKey;
  
  const handleToggle = (key: string) => {
    let newActiveKey: string | string[];
    
    if (accordion) {
      newActiveKey = activeKey === key ? '' : key;
    } else {
      const keys = Array.isArray(activeKey) ? activeKey : [activeKey];
      newActiveKey = keys.includes(key)
        ? keys.filter(k => k !== key)
        : [...keys, key];
    }
    
    if (!isControlled) {
      setInternalActiveKey(newActiveKey);
    }
    
    onChange?.(newActiveKey);
  };
  
  return (
    <div className={classNames('chips-collapse', className)}>
      {React.Children.map(children, child => {
        if (React.isValidElement<CollapsePanelProps>(child)) {
          const isActive = accordion
            ? activeKey === child.props.key
            : Array.isArray(activeKey) && activeKey.includes(child.props.key);
          
          return React.cloneElement(child, {
            ...child.props,
            active: isActive,
            onToggle: () => handleToggle(child.props.key),
          } as any);
        }
        return child;
      })}
    </div>
  );
}

export function Panel({
  header,
  disabled = false,
  children,
  active,
  onToggle,
}: CollapsePanelProps & { active?: boolean; onToggle?: () => void }) {
  return (
    <div
      className={classNames('chips-collapse-panel', {
        'chips-collapse-panel-active': active,
        'chips-collapse-panel-disabled': disabled,
      })}
    >
      <div
        className="chips-collapse-panel-header"
        onClick={() => !disabled && onToggle?.()}
      >
        {header}
        <span className="chips-collapse-panel-arrow">
          <DownIcon />
        </span>
      </div>
      {active && (
        <div className="chips-collapse-panel-content">{children}</div>
      )}
    </div>
  );
}

Collapse.Panel = Panel;
```

## 总结

布局组件库提供了构建页面结构的核心工具。Grid 栅格系统支持响应式布局，Flex 提供灵活的弹性布局，Container 提供内容容器，Layout 提供整体页面结构，Space 控制元素间距，Card 提供卡片容器，Collapse 提供折叠面板。所有组件都遵循功能与样式分离的原则，提供清晰的样式接口点供主题包定制。

**重要说明**：
- 箱子布局（瀑布流、网格、时间线等）的**具体实现在布局插件中**
- 组件库只提供 `BoxLayoutView` 作为 iframe 容器组件
- 开发者使用 `BoxLayoutView` 传入布局插件ID，即可显示对应布局
