# 组件开发指南

## 开发环境搭建

### 安装依赖

```bash
# 克隆组件库仓库
git clone https://github.com/chips-ui/components.git
cd components

# 安装依赖
npm install

# 启动开发服务器
npm run dev
```

### 项目结构

```
chips-ui/
├── src/
│   ├── components/          # 组件源代码
│   │   ├── Button/
│   │   │   ├── index.tsx
│   │   │   ├── Button.tsx
│   │   │   ├── types.ts
│   │   │   └── __tests__/
│   │   │       └── Button.test.tsx
│   │   ├── Input/
│   │   └── ...
│   ├── hooks/               # 自定义Hooks
│   ├── utils/               # 工具函数
│   ├── constants/           # 常量定义
│   ├── types/               # 类型定义
│   └── index.ts             # 入口文件
├── docs/                    # 文档
├── examples/                # 示例代码
├── tests/                   # 测试文件
├── scripts/                 # 构建脚本
├── package.json
├── tsconfig.json
├── .eslintrc.js
└── README.md
```

## 创建新组件

### 第一步：创建组件目录

```bash
# 创建组件目录
mkdir -p src/components/MyComponent

# 创建必需文件
touch src/components/MyComponent/index.tsx
touch src/components/MyComponent/MyComponent.tsx
touch src/components/MyComponent/types.ts
touch src/components/MyComponent/__tests__/MyComponent.test.tsx
```

### 第二步：定义类型

```typescript
// src/components/MyComponent/types.ts
import { ReactNode } from 'react';

export interface MyComponentProps {
  // 必需属性
  value: string;
  
  // 可选属性
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  
  // 内容
  children?: ReactNode;
  
  // 事件回调
  onChange?: (value: string) => void;
  onClick?: (event: MouseEvent) => void;
  
  // 样式
  className?: string;
}
```

### 第三步：实现组件

```typescript
// src/components/MyComponent/MyComponent.tsx
import { useState } from 'react';
import { classNames } from '../../utils/classNames';
import { MyComponentProps } from './types';

export function MyComponent({
  value: controlledValue,
  size = 'medium',
  disabled = false,
  children,
  onChange,
  onClick,
  className,
  ...rest
}: MyComponentProps) {
  // 状态管理
  const isControlled = controlledValue !== undefined;
  const [internalValue, setInternalValue] = useState('');
  const value = isControlled ? controlledValue : internalValue;
  
  // 样式类名
  const componentClassName = classNames(
    'chips-my-component',
    `chips-my-component-${size}`,
    {
      'chips-my-component-disabled': disabled,
    },
    className
  );
  
  // 事件处理
  const handleChange = (newValue: string) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue);
  };
  
  const handleClick = (event: MouseEvent) => {
    if (disabled) {
      event.preventDefault();
      return;
    }
    onClick?.(event);
  };
  
  // 渲染
  return (
    <div className={componentClassName} {...rest}>
      {/* 组件内容 */}
      {children}
    </div>
  );
}
```

### 第四步：创建入口文件

```typescript
// src/components/MyComponent/index.tsx
export { MyComponent } from './MyComponent';
export type { MyComponentProps } from './types';
```

### 第五步：编写测试

```typescript
// src/components/MyComponent/__tests__/MyComponent.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { MyComponent } from '../MyComponent';

describe('MyComponent', () => {
  it('应该正确渲染', () => {
    render(<MyComponent value="test">内容</MyComponent>);
    expect(screen.getByText('内容')).toBeInTheDocument();
  });
  
  it('应该处理点击事件', () => {
    const handleClick = jest.fn();
    render(<MyComponent value="test" onClick={handleClick} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('禁用状态不应触发事件', () => {
    const handleClick = jest.fn();
    render(<MyComponent value="test" disabled onClick={handleClick} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).not.toHaveBeenCalled();
  });
});
```

### 第六步：编写文档

```markdown
<!-- docs/components/MyComponent.md -->
# MyComponent 我的组件

组件描述...

## 何时使用

- 场景1
- 场景2

## 代码示例

### 基础用法

\`\`\`tsx
<MyComponent value="hello">
  内容
</MyComponent>
\`\`\`

### 不同尺寸

\`\`\`tsx
<MyComponent size="small" value="small">小尺寸</MyComponent>
<MyComponent size="medium" value="medium">中尺寸</MyComponent>
<MyComponent size="large" value="large">大尺寸</MyComponent>
\`\`\`

## API

### MyComponent Props

| 参数 | 说明 | 类型 | 默认值 |
|------|------|------|--------|
| value | 组件值 | `string` | - |
| size | 尺寸 | `'small' \| 'medium' \| 'large'` | `'medium'` |
| disabled | 是否禁用 | `boolean` | `false` |
| onChange | 值变化回调 | `(value: string) => void` | - |
| onClick | 点击回调 | `(event: MouseEvent) => void` | - |

### 样式接口点

| 类名 | 说明 |
|------|------|
| `.chips-my-component` | 组件容器 |
| `.chips-my-component-small` | 小尺寸 |
| `.chips-my-component-medium` | 中尺寸 |
| `.chips-my-component-large` | 大尺寸 |
| `.chips-my-component-disabled` | 禁用状态 |
```

### 第七步：导出组件

```typescript
// src/index.ts
export { MyComponent } from './components/MyComponent';
export type { MyComponentProps } from './components/MyComponent';
```

## 开发规范

### 命名规范

**组件命名**
- 使用PascalCase: `Button`, `InputField`, `DatePicker`
- 组件名应该明确描述功能
- 避免缩写: `TextField`而不是`TxtFld`

**Props命名**
- 布尔值使用is/has/should前缀: `isOpen`, `hasError`, `shouldUpdate`
- 事件回调使用on前缀: `onClick`, `onChange`, `onSubmit`
- 渲染函数使用render前缀: `renderItem`, `renderHeader`

**CSS类名**
- 使用kebab-case: `chips-button`, `chips-input-field`
- 遵循BEM命名: `chips-button__icon`, `chips-button--primary`
- 所有类名以`chips-`前缀开头

### 代码风格

**使用TypeScript**
```typescript
// ✅ 好: 明确的类型定义
interface ButtonProps {
  type: 'primary' | 'default';
  onClick: (event: MouseEvent<HTMLButtonElement>) => void;
}

// ❌ 避免: 使用any
interface ButtonProps {
  type: string;
  onClick: any;
}
```

**使用函数组件**
```typescript
// ✅ 好: 函数组件
export function Button(props: ButtonProps) {
  return <button>{props.children}</button>;
}

// ❌ 避免: 类组件(除非必要)
class Button extends React.Component<ButtonProps> {
  render() {
    return <button>{this.props.children}</button>;
  }
}
```

**Props解构**
```typescript
// ✅ 好: 在参数中解构
export function Button({ type, children, onClick }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}

// ❌ 避免: 在函数体中解构
export function Button(props: ButtonProps) {
  const { type, children, onClick } = props;
  return <button onClick={onClick}>{children}</button>;
}
```

### 性能优化

**使用React.memo**
```typescript
export const Button = React.memo(function Button(props: ButtonProps) {
  // 组件实现
});
```

**使用useCallback缓存函数**
```typescript
const handleClick = useCallback(() => {
  console.log('clicked');
}, []);
```

**使用useMemo缓存计算结果**
```typescript
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.value - b.value);
}, [items]);
```

### 可访问性

**语义化HTML**
```typescript
// ✅ 好: 使用语义化标签
<button type="button" onClick={handleClick}>
  点击
</button>

// ❌ 避免: 使用div模拟按钮
<div onClick={handleClick}>
  点击
</div>
```

**ARIA属性**
```typescript
<button
  type="button"
  aria-label="关闭"
  aria-pressed={pressed}
  aria-disabled={disabled}
>
  <CloseIcon />
</button>
```

**键盘导航**
```typescript
const handleKeyDown = (event: KeyboardEvent) => {
  if (event.key === 'Enter' || event.key === ' ') {
    handleClick();
  }
};
```

## 调试技巧

### 使用开发工具

```typescript
// 在开发模式下输出调试信息
if (process.env.NODE_ENV === 'development') {
  console.log('组件Props:', props);
  console.log('组件状态:', state);
}
```

### 使用React DevTools

- 安装React DevTools浏览器扩展
- 检查组件树结构
- 查看组件Props和State
- 分析组件渲染性能

### 使用断点调试

在代码中设置断点:
```typescript
export function MyComponent(props: MyComponentProps) {
  debugger; // 执行到这里会暂停
  
  // 组件逻辑
}
```

## 测试

### 单元测试

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '../Button';

describe('Button', () => {
  it('应该渲染文本内容', () => {
    render(<Button>点击我</Button>);
    expect(screen.getByText('点击我')).toBeInTheDocument();
  });
  
  it('应该响应点击事件', async () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>点击我</Button>);
    
    await userEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('禁用时不应响应点击', async () => {
    const handleClick = jest.fn();
    render(<Button disabled onClick={handleClick}>点击我</Button>);
    
    await userEvent.click(screen.getByRole('button'));
    expect(handleClick).not.toHaveBeenCalled();
  });
});
```

### 快照测试

```typescript
it('应该匹配快照', () => {
  const { container } = render(
    <Button type="primary" size="large">
      点击我
    </Button>
  );
  expect(container.firstChild).toMatchSnapshot();
});
```

### 可访问性测试

```typescript
import { axe } from 'jest-axe';

it('应该符合无障碍标准', async () => {
  const { container } = render(<Button>点击我</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

## 发布流程

### 版本管理

遵循语义化版本规范:
- 主版本号: 不兼容的API修改
- 次版本号: 向后兼容的功能性新增
- 修订号: 向后兼容的bug修复

```bash
# 修订版本 (1.0.0 -> 1.0.1)
npm version patch

# 次版本 (1.0.0 -> 1.1.0)
npm version minor

# 主版本 (1.0.0 -> 2.0.0)
npm version major
```

### 构建

```bash
# 运行测试
npm test

# 类型检查
npm run type-check

# Lint检查
npm run lint

# 构建
npm run build
```

### 发布到npm

```bash
# 登录npm
npm login

# 发布
npm publish

# 发布beta版本
npm publish --tag beta
```

## 贡献指南

### 提交代码

1. Fork仓库
2. 创建特性分支: `git checkout -b feature/my-feature`
3. 提交改动: `git commit -m 'feat: add new feature'`
4. 推送到分支: `git push origin feature/my-feature`
5. 创建Pull Request

### Commit规范

遵循Conventional Commits规范:

```bash
# 新功能
git commit -m "feat: 添加Button组件"

# Bug修复
git commit -m "fix: 修复Input组件的边框样式"

# 文档更新
git commit -m "docs: 更新README文档"

# 代码重构
git commit -m "refactor: 重构Modal组件"

# 性能优化
git commit -m "perf: 优化Table组件渲染性能"

# 测试
git commit -m "test: 添加Select组件测试"

# 构建
git commit -m "build: 更新webpack配置"
```

### Code Review清单

- [ ] 代码符合项目规范
- [ ] 有完整的TypeScript类型定义
- [ ] 有单元测试覆盖
- [ ] 有完整的文档
- [ ] 通过所有测试
- [ ] 通过Lint检查
- [ ] 符合无障碍标准
- [ ] 性能表现良好

## 常见问题

### 如何处理受控和非受控?

```typescript
function Input({ value: controlledValue, defaultValue, onChange }: InputProps) {
  const isControlled = controlledValue !== undefined;
  const [internalValue, setInternalValue] = useState(defaultValue || '');
  
  const value = isControlled ? controlledValue : internalValue;
  
  const handleChange = (newValue: string) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue);
  };
  
  return <input value={value} onChange={e => handleChange(e.target.value)} />;
}
```

### 如何避免不必要的重渲染?

```typescript
// 使用React.memo
export const Button = React.memo(Button);

// 使用useCallback
const handleClick = useCallback(() => {
  // 处理逻辑
}, [依赖项]);

// 使用useMemo
const computedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);
```

### 如何处理异步操作?

```typescript
function AsyncComponent() {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const result = await api.fetch();
        if (!cancelled) {
          setData(result);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, []);
  
  if (loading) return <Loading />;
  if (error) return <Error error={error} />;
  return <div>{data}</div>;
}
```

## 总结

组件开发需要遵循一致的规范和最佳实践。从项目搭建、组件创建、代码实现、测试编写到文档撰写,每个环节都有明确的指导。通过遵循这些指南,可以创建高质量、易维护、性能优秀的组件。
